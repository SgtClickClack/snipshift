/**
 * Shift Slot Generator Utility
 * 
 * Generates shift slots based on opening hours and shift patterns
 * Ported from frontend utility for server-side use
 */

export interface OpeningHours {
  [key: string]: { open: string; close: string; enabled: boolean } | undefined;
  monday: { open: string; close: string; enabled: boolean };
  tuesday: { open: string; close: string; enabled: boolean };
  wednesday: { open: string; close: string; enabled: boolean };
  thursday: { open: string; close: string; enabled: boolean };
  friday: { open: string; close: string; enabled: boolean };
  saturday: { open: string; close: string; enabled: boolean };
  sunday: { open: string; close: string; enabled: boolean };
}

export type ShiftPattern = 'half-day' | 'thirds' | 'full-day' | 'custom';

export interface CalendarSettings {
  openingHours: OpeningHours;
  shiftPattern: ShiftPattern;
  defaultShiftLength?: number; // in hours, for custom pattern
}

export interface GeneratedShiftSlot {
  id: string; // Virtual ID for auto-generated slots
  start: Date;
  end: Date;
  dayOfWeek: string;
  slotIndex: number; // Index within the day (0, 1, 2 for thirds, etc.)
  pattern: ShiftPattern;
  isAutoGenerated: true;
  status: 'unassigned' | 'open';
}

/**
 * Calculate shift slots for a given day based on opening hours and shift pattern
 */
export function calculateShiftSlotsForDay(
  date: Date,
  openingHours: OpeningHours,
  pattern: ShiftPattern,
  customShiftLength?: number
): GeneratedShiftSlot[] {
  const dayOfWeek = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'][date.getDay()];
  const dayHours = openingHours[dayOfWeek];

  // If day is not enabled or no hours set, return empty array
  if (!dayHours || !dayHours.enabled || !dayHours.open || !dayHours.close) {
    return [];
  }

  const [openHour, openMin] = dayHours.open.split(':').map(Number);
  const [closeHour, closeMin] = dayHours.close.split(':').map(Number);

  const dayStart = new Date(date);
  dayStart.setHours(0, 0, 0, 0);
  
  const openTime = new Date(dayStart);
  openTime.setHours(openHour, openMin, 0, 0);

  const closeTime = new Date(dayStart);
  closeTime.setHours(closeHour, closeMin, 0, 0);

  // Ensure close time is after open time
  if (closeTime <= openTime) {
    return [];
  }

  const totalMinutes = (closeTime.getTime() - openTime.getTime()) / (1000 * 60);
  const slots: GeneratedShiftSlot[] = [];

  const formatDate = (d: Date) => {
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  };

  switch (pattern) {
    case 'half-day': {
      const halfPoint = totalMinutes / 2;
      const midTime = new Date(openTime.getTime() + halfPoint * 60 * 1000);
      
      slots.push({
        id: `auto-${formatDate(date)}-0`,
        start: openTime,
        end: midTime,
        dayOfWeek,
        slotIndex: 0,
        pattern: 'half-day',
        isAutoGenerated: true,
        status: 'unassigned',
      });
      
      slots.push({
        id: `auto-${formatDate(date)}-1`,
        start: midTime,
        end: closeTime,
        dayOfWeek,
        slotIndex: 1,
        pattern: 'half-day',
        isAutoGenerated: true,
        status: 'unassigned',
      });
      break;
    }

    case 'thirds': {
      const third = totalMinutes / 3;
      const firstThird = new Date(openTime.getTime() + third * 60 * 1000);
      const secondThird = new Date(openTime.getTime() + (third * 2) * 60 * 1000);
      
      slots.push({
        id: `auto-${formatDate(date)}-0`,
        start: openTime,
        end: firstThird,
        dayOfWeek,
        slotIndex: 0,
        pattern: 'thirds',
        isAutoGenerated: true,
        status: 'unassigned',
      });
      
      slots.push({
        id: `auto-${formatDate(date)}-1`,
        start: firstThird,
        end: secondThird,
        dayOfWeek,
        slotIndex: 1,
        pattern: 'thirds',
        isAutoGenerated: true,
        status: 'unassigned',
      });
      
      slots.push({
        id: `auto-${formatDate(date)}-2`,
        start: secondThird,
        end: closeTime,
        dayOfWeek,
        slotIndex: 2,
        pattern: 'thirds',
        isAutoGenerated: true,
        status: 'unassigned',
      });
      break;
    }

    case 'custom': {
      // Handle decimal hours (e.g., 4.5 hours = 4 hours 30 minutes)
      const shiftLengthMinutes = Math.round((customShiftLength || 8) * 60);
      let currentStart = openTime;
      let slotIndex = 0;

      while (currentStart < closeTime) {
        const slotEnd = new Date(currentStart.getTime() + shiftLengthMinutes * 60 * 1000);
        // Create a shorter final shift if needed (Partial Shift)
        const actualEnd = slotEnd > closeTime ? closeTime : slotEnd;
        
        // Only create slot if it's at least 15 minutes (minimum viable shift)
        const slotDuration = (actualEnd.getTime() - currentStart.getTime()) / (1000 * 60);
        if (slotDuration >= 15) {
          slots.push({
            id: `auto-${formatDate(date)}-${slotIndex}`,
            start: new Date(currentStart),
            end: actualEnd,
            dayOfWeek,
            slotIndex,
            pattern: 'custom',
            isAutoGenerated: true,
            status: 'unassigned',
          });
        }

        currentStart = actualEnd;
        slotIndex++;

        // Prevent infinite loop
        if (slotIndex > 20) break;
      }
      break;
    }

    case 'full-day':
    default: {
      slots.push({
        id: `auto-${formatDate(date)}-0`,
        start: openTime,
        end: closeTime,
        dayOfWeek,
        slotIndex: 0,
        pattern: 'full-day',
        isAutoGenerated: true,
        status: 'unassigned',
      });
      break;
    }
  }

  return slots;
}

/**
 * Generate shift slots for a date range
 */
export function generateShiftSlotsForRange(
  startDate: Date,
  endDate: Date,
  settings: CalendarSettings
): GeneratedShiftSlot[] {
  const slots: GeneratedShiftSlot[] = [];
  const currentDate = new Date(startDate);
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  while (currentDate <= endDate) {
    const currentDay = new Date(currentDate);
    currentDay.setHours(0, 0, 0, 0);
    
    // Skip past dates (only generate for today and future)
    if (currentDay >= today) {
      const daySlots = calculateShiftSlotsForDay(
        currentDate,
        settings.openingHours,
        settings.shiftPattern,
        settings.defaultShiftLength
      );
      slots.push(...daySlots);
    }

    currentDate.setDate(currentDate.getDate() + 1);
  }

  return slots;
}

/**
 * Check if a generated slot overlaps with an existing shift
 */
export function slotOverlapsWithShift(
  slot: GeneratedShiftSlot,
  existingShifts: Array<{ start: Date | string; end: Date | string }>
): boolean {
  const slotStart = slot.start;
  const slotEnd = slot.end;

  return existingShifts.some(shift => {
    const shiftStart = new Date(shift.start);
    const shiftEnd = new Date(shift.end);

    // Check for overlap
    return (
      (slotStart >= shiftStart && slotStart < shiftEnd) ||
      (slotEnd > shiftStart && slotEnd <= shiftEnd) ||
      (slotStart <= shiftStart && slotEnd >= shiftEnd)
    );
  });
}

/**
 * Filter out auto-generated slots that overlap with existing shifts
 */
export function filterOverlappingSlots(
  generatedSlots: GeneratedShiftSlot[],
  existingShifts: Array<{ start: Date | string; end: Date | string }>
): GeneratedShiftSlot[] {
  return generatedSlots.filter(slot => !slotOverlapsWithShift(slot, existingShifts));
}

