import { useState, useMemo, useCallback, useEffect, useRef, Component, ReactNode } from "react";
import { Calendar, dateFnsLocalizer, View, Event } from "react-big-calendar";
import {
  format,
  parse,
  startOfWeek,
  getDay,
  isPast,
  isToday,
  endOfWeek,
  eachDayOfInterval,
  isSameDay,
  addWeeks,
  subWeeks,
} from "date-fns";
import enUS from "date-fns/locale/en-US";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Calendar as CalendarComponent } from "@/components/ui/calendar";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Calendar as CalendarIcon,
  Plus,
  Clock,
  MapPin,
  DollarSign,
  Filter,
  ChevronLeft,
  ChevronRight,
  Repeat,
  Trash2,
  Search,
  Star,
  Settings,
} from "lucide-react";
// Import UserPlus separately to ensure it's properly included in the bundle
import { UserPlus } from "lucide-react";
// Store reference to prevent tree-shaking in production builds
const UserPlusIcon = UserPlus;
import { useToast } from "@/hooks/useToast";
import { apiRequest } from "@/lib/queryClient";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useNotification } from "@/contexts/NotificationContext";
import StartChatButton from "@/components/messaging/start-chat-button";
import { ShiftBlock } from "./shift-block";
import { AssignStaffModal, Professional } from "./assign-staff-modal";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Checkbox } from "@/components/ui/checkbox";
import CalendarSettingsModal, { CalendarSettings, ShiftPattern, OpeningHours } from "./calendar-settings-modal";
import { AutoFillButton } from "./auto-fill-button";
import { SmartFillConfirmationModal, SmartMatch } from "./smart-fill-confirmation-modal";
import { calculateSmartMatches } from "./smart-fill-utils";
import { useAuth } from "@/contexts/AuthContext";
import { 
  generateShiftSlotsForRange, 
  filterOverlappingSlots, 
  GeneratedShiftSlot 
} from "@/utils/shift-slot-generator";
import { AutoSlotAssignmentModal } from "./auto-slot-assignment-modal";
import { fetchProfessionals, ProfessionalListItem } from "@/lib/api";
import { ShiftAssignmentModal } from "./shift-assignment-modal";
import { CalendarToolbar } from "./CalendarToolbar";

// Import react-big-calendar CSS
import "react-big-calendar/lib/css/react-big-calendar.css";

// Initialize localizer with error handling
const locales = {
  'en-US': enUS,
};

let localizer: ReturnType<typeof dateFnsLocalizer> | null = null;
try {
  localizer = dateFnsLocalizer({
    format,
    parse,
    startOfWeek,
    getDay,
    locales,
  });
  console.log('[CALENDAR INIT] Localizer initialized successfully');
} catch (error) {
  console.error('[CALENDAR INIT] Failed to initialize localizer:', error);
}

// Validate localizer at module load time
if (!localizer) {
  console.error('[CALENDAR INIT] Localizer is null - Calendar will not render');
}

// Extend Event type to include our custom properties
interface CalendarEvent extends Event {
  id: string;
  title: string;
  start: Date;
  end: Date;
  resource: {
    booking?: any;
    status: "draft" | "invited" | "confirmed" | "pending" | "completed" | "past" | "unassigned";
    type: "job" | "shift" | "auto-slot";
    isAutoGenerated?: boolean;
    generatedSlot?: GeneratedShiftSlot;
  };
}

interface ProfessionalCalendarProps {
  bookings?: any[] | null;
  isLoading?: boolean;
  onDateSelect?: (date: Date) => void;
  /** Mode: 'professional' for My Shifts, 'business' for All Company Shifts */
  mode?: 'professional' | 'business';
  /** Callback when Create button is clicked in business mode (opens Create New Shift modal) */
  onCreateShift?: () => void;
}

type JobStatus = "all" | "pending" | "confirmed" | "completed";

// Error Boundary for Calendar Component
interface CalendarErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

class CalendarErrorBoundary extends Component<
  { children: ReactNode },
  CalendarErrorBoundaryState
> {
  constructor(props: { children: ReactNode }) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): CalendarErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('[CALENDAR ERROR BOUNDARY] Caught error:', error);
    console.error('[CALENDAR ERROR BOUNDARY] Error info:', errorInfo);
    console.error('[CALENDAR ERROR BOUNDARY] Error stack:', error.stack);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div 
          className="flex items-center justify-center h-full min-h-[600px]" 
          data-testid="calendar-error-boundary"
        >
          <div className="text-muted-foreground">
            Calendar render error: {this.state.error?.message || 'Unknown error'}
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

// Current Time Indicator Component - Red line like Google Calendar
function CurrentTimeIndicator({
  currentTime,
  view,
  currentDate,
}: {
  currentTime: Date;
  view: View;
  currentDate: Date;
}) {
  const isToday = isSameDay(currentTime, currentDate);
  const isInCurrentWeek =
    view === "week" &&
    currentTime >= startOfWeek(currentDate, { weekStartsOn: 0 }) &&
    currentTime <= endOfWeek(currentDate, { weekStartsOn: 0 });

  if ((view === "week" && !isInCurrentWeek) || (view === "day" && !isToday)) {
    return null;
  }

  const hours = currentTime.getHours();
  const minutes = currentTime.getMinutes();
  const totalMinutes = hours * 60 + minutes;
  // Calculate position: calendar typically shows 6 AM to 11 PM (17 hours = 1020 minutes)
  // Starting from 6 AM (360 minutes)
  const startHour = 6;
  const endHour = 23;
  const startMinutes = startHour * 60;
  const endMinutes = endHour * 60;
  const totalRange = endMinutes - startMinutes;
  const positionFromStart = totalMinutes - startMinutes;
  const topPosition = Math.max(0, Math.min(100, (positionFromStart / totalRange) * 100));

  return (
    <div
      className="absolute left-0 right-0 pointer-events-none"
      style={{
        top: `${topPosition}%`,
        marginTop: "-1px",
        zIndex: 30, // Above grid lines and events
      }}
    >
      <div className="flex items-center h-0.5">
        <div className="w-14 text-xs text-red-600 font-medium pr-2 pl-1 text-right bg-red-50 dark:bg-red-950/80 rounded-full border border-red-200 dark:border-red-900/50">
          {format(currentTime, "h:mm a")}
        </div>
        <div className="flex-1 relative">
          <div className="h-0.5 bg-red-600 relative">
            <div className="absolute -left-1.5 -top-1.5 w-3 h-3 bg-red-600 rounded-full border-2 border-background"></div>
          </div>
        </div>
      </div>
    </div>
  );
}

export default function ProfessionalCalendar({
  bookings = [],
  isLoading = false,
  onDateSelect,
  mode = 'professional',
  onCreateShift,
}: ProfessionalCalendarProps) {
  // Log component mount/unmount for debugging reloads
  useEffect(() => {
    console.log('[CALENDAR COMPONENT] ProfessionalCalendar component mounted');
    console.log('[CALENDAR COMPONENT] Props:', { 
      bookingsCount: Array.isArray(bookings) ? bookings.length : 'not array',
      isLoading,
      hasOnDateSelect: !!onDateSelect
    });
    
    return () => {
      console.log('[CALENDAR COMPONENT] ProfessionalCalendar component unmounting');
    };
  }, []); // Only log on mount/unmount
  
  // Track re-renders to debug *true* loops (avoid false positives from expected timers)
  const renderRateRef = useRef<{ windowStart: number; count: number }>({
    windowStart: Date.now(),
    count: 0,
  });
  {
    const now = Date.now();
    const elapsed = now - renderRateRef.current.windowStart;
    if (elapsed > 1000) {
      renderRateRef.current.windowStart = now;
      renderRateRef.current.count = 0;
    }
    renderRateRef.current.count += 1;
    if (renderRateRef.current.count > 10) {
      console.warn('[CALENDAR COMPONENT] Excessive re-renders detected (within 1s):', renderRateRef.current.count);
    }
  }
  
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const { user } = useAuth();
  const { addNotification } = useNotification();
  const [currentDate, setCurrentDate] = useState<Date>(() => {
    const date = new Date();
    // Ensure date is valid
    if (isNaN(date.getTime())) {
      return new Date();
    }
    return date;
  });
  // Mobile Squeeze fix: Use 'agenda' or 'day' view on mobile instead of 'month' (which is unreadable)
  const [view, setView] = useState<View>(() => {
    // Check if we're on mobile (window width < 768px)
    if (typeof window !== 'undefined' && window.innerWidth < 768) {
      return 'day'; // Use 'day' view on mobile for better readability
    }
    return 'month'; // Default to 'month' view on desktop
  });
  const [selectedEvent, setSelectedEvent] = useState<CalendarEvent | null>(null);
  const [showEventDetails, setShowEventDetails] = useState(false);
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [selectedDate, setSelectedDate] = useState<Date | undefined>(() => {
    const date = new Date();
    return isNaN(date.getTime()) ? undefined : date;
  });
  const [selectedSlot, setSelectedSlot] = useState<{ start: Date; end: Date } | null>(null);
  const [newEventTitle, setNewEventTitle] = useState("");
  const [shiftFormData, setShiftFormData] = useState({
    title: "",
    description: "",
    date: "",
    startTime: "09:00",
    endTime: "17:00",
    hourlyRate: "45",
    location: "",
  });
  const [statusFilter, setStatusFilter] = useState<JobStatus>("all");
  const [currentTime, setCurrentTime] = useState(new Date());
  const calendarRef = useRef<HTMLDivElement>(null);
  const timeIndicatorRef = useRef<HTMLDivElement>(null);
  const [showAssignStaffModal, setShowAssignStaffModal] = useState(false);
  const [selectedShiftForAssignment, setSelectedShiftForAssignment] = useState<CalendarEvent | null>(null);
  const [showSmartFillModal, setShowSmartFillModal] = useState(false);
  const [showFindProfessionalMode, setShowFindProfessionalMode] = useState(false);
  const [showRecurringDialog, setShowRecurringDialog] = useState(false);
  const [showCalendarSettings, setShowCalendarSettings] = useState(false);
  const [showAutoSlotAssignment, setShowAutoSlotAssignment] = useState(false);
  const [selectedAutoSlot, setSelectedAutoSlot] = useState<GeneratedShiftSlot | null>(null);
  const [showShiftAssignmentModal, setShowShiftAssignmentModal] = useState(false);
  const [selectedUnassignedSlot, setSelectedUnassignedSlot] = useState<{ start: Date; end: Date } | null>(null);
  
  // Calendar settings - stored in localStorage
  const getSettingsKey = useCallback(() => {
    return `calendar-settings-${user?.id || 'default'}`;
  }, [user?.id]);
  
  // Helper function to convert business settings to calendar settings format
  const convertBusinessSettingsToCalendarSettings = useCallback((businessSettings: any): CalendarSettings | null => {
    if (!businessSettings || !businessSettings.openingHours) {
      return null;
    }
    
    // Convert shiftSplitType to shiftPattern
    let shiftPattern: ShiftPattern = 'full-day';
    if (businessSettings.shiftSplitType === 'halves') {
      shiftPattern = 'half-day';
    } else if (businessSettings.shiftSplitType === 'thirds') {
      shiftPattern = 'thirds';
    } else if (businessSettings.shiftSplitType === 'custom') {
      shiftPattern = 'custom';
    } else {
      shiftPattern = 'full-day';
    }
    
    return {
      openingHours: businessSettings.openingHours,
      shiftPattern,
      defaultShiftLength: businessSettings.customShiftLength,
    };
  }, []);
  
  const [calendarSettings, setCalendarSettings] = useState<CalendarSettings | null>(() => {
    if (typeof window === 'undefined') return null;
    try {
      // First try to load from user.businessSettings
      if (user?.businessSettings) {
        const converted = convertBusinessSettingsToCalendarSettings(user.businessSettings);
        if (converted) {
          return converted;
        }
      }
      // Fallback to localStorage
      const key = `calendar-settings-${user?.id || 'default'}`;
      const stored = localStorage.getItem(key);
      return stored ? JSON.parse(stored) : null;
    } catch {
      return null;
    }
  });

  const normalizeCalendarSettingsForCompare = useCallback((settings: CalendarSettings | null) => {
    if (!settings) return null;

    // Ensure stable key order + presence for JSON comparisons (prevents render loops
    // when upstream objects get recreated with the same values).
    const openingHours = settings.openingHours || ({} as CalendarSettings['openingHours']);
    const fallbackWeekday = { open: '09:00', close: '18:00', enabled: false };
    const fallbackWeekend = { open: '09:00', close: '17:00', enabled: false };

    return {
      shiftPattern: settings.shiftPattern,
      defaultShiftLength: settings.defaultShiftLength,
      openingHours: {
        monday: openingHours.monday || fallbackWeekday,
        tuesday: openingHours.tuesday || fallbackWeekday,
        wednesday: openingHours.wednesday || fallbackWeekday,
        thursday: openingHours.thursday || fallbackWeekday,
        friday: openingHours.friday || fallbackWeekday,
        saturday: openingHours.saturday || fallbackWeekend,
        sunday: openingHours.sunday || fallbackWeekend,
      },
    };
  }, []);

  const areCalendarSettingsEqual = useCallback(
    (a: CalendarSettings | null, b: CalendarSettings | null) => {
      return (
        JSON.stringify(normalizeCalendarSettingsForCompare(a)) ===
        JSON.stringify(normalizeCalendarSettingsForCompare(b))
      );
    },
    [normalizeCalendarSettingsForCompare]
  );
  
  // Save settings to localStorage
  const handleSaveSettings = useCallback((settings: CalendarSettings) => {
    console.log('[CALENDAR] Saving settings:', settings);
    // Ensure all days are present in openingHours
    const completeSettings: CalendarSettings = {
      ...settings,
      openingHours: {
        monday: settings.openingHours.monday || { open: '09:00', close: '18:00', enabled: false },
        tuesday: settings.openingHours.tuesday || { open: '09:00', close: '18:00', enabled: false },
        wednesday: settings.openingHours.wednesday || { open: '09:00', close: '18:00', enabled: false },
        thursday: settings.openingHours.thursday || { open: '09:00', close: '18:00', enabled: false },
        friday: settings.openingHours.friday || { open: '09:00', close: '18:00', enabled: false },
        saturday: settings.openingHours.saturday || { open: '09:00', close: '17:00', enabled: false },
        sunday: settings.openingHours.sunday || { open: '09:00', close: '17:00', enabled: false },
      },
    };
    setCalendarSettings(completeSettings);
    if (typeof window !== 'undefined') {
      try {
        const key = getSettingsKey();
        localStorage.setItem(key, JSON.stringify(completeSettings));
        console.log('[CALENDAR] Settings saved to localStorage:', completeSettings);
      } catch (error) {
        console.error('Failed to save calendar settings:', error);
      }
    }
  }, [getSettingsKey]);
  
  // Reload settings when user changes or businessSettings updates
  useEffect(() => {
    if (typeof window !== 'undefined') {
      try {
        // Priority 1: Load from user.businessSettings (from database)
        if (user?.businessSettings) {
          const converted = convertBusinessSettingsToCalendarSettings(user.businessSettings);
          if (converted) {
            setCalendarSettings((prev) => (areCalendarSettingsEqual(prev, converted) ? prev : converted));
            // Also save to localStorage for consistency
            const key = getSettingsKey();
            localStorage.setItem(key, JSON.stringify(converted));
            console.log('[CALENDAR] Settings loaded from user.businessSettings:', converted);
            return;
          }
        }
        
        // Priority 2: Load from localStorage
        const key = getSettingsKey();
        const stored = localStorage.getItem(key);
        if (stored) {
          const parsed = JSON.parse(stored);
          setCalendarSettings((prev) => (areCalendarSettingsEqual(prev, parsed) ? prev : parsed));
          console.log('[CALENDAR] Settings loaded from localStorage:', parsed);
        } else {
          setCalendarSettings((prev) => (prev === null ? prev : null));
        }
      } catch (error) {
        console.error('[CALENDAR] Error loading settings:', error);
        setCalendarSettings((prev) => (prev === null ? prev : null));
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [user?.id, user?.businessSettings, getSettingsKey, convertBusinessSettingsToCalendarSettings, areCalendarSettingsEqual]);
  
  // Listen for storage events and custom events to sync settings when they're updated from other components
  useEffect(() => {
    if (typeof window === 'undefined') return;
    
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === getSettingsKey() && e.newValue) {
        try {
          const parsed = JSON.parse(e.newValue);
          setCalendarSettings((prev) => (areCalendarSettingsEqual(prev, parsed) ? prev : parsed));
          console.log('[CALENDAR] Settings synced from storage event:', parsed);
        } catch (error) {
          console.error('[CALENDAR] Failed to parse settings from storage event:', error);
        }
      }
    };
    
    const handleCustomEvent = (e: CustomEvent) => {
      if (e.detail?.settings) {
        const nextSettings = e.detail.settings as CalendarSettings;
        setCalendarSettings((prev) => (areCalendarSettingsEqual(prev, nextSettings) ? prev : nextSettings));
        console.log('[CALENDAR] Settings synced from custom event:', e.detail.settings);
      }
    };
    
    window.addEventListener('storage', handleStorageChange);
    window.addEventListener('calendarSettingsUpdated', handleCustomEvent as EventListener);
    return () => {
      window.removeEventListener('storage', handleStorageChange);
      window.removeEventListener('calendarSettingsUpdated', handleCustomEvent as EventListener);
    };
  }, [getSettingsKey, areCalendarSettingsEqual]);
  
  // Log when calendarSettings changes to verify re-renders
  useEffect(() => {
    if (calendarSettings) {
      console.log('[CALENDAR] Settings updated, will regenerate events:', {
        hasOpeningHours: !!calendarSettings.openingHours,
        enabledDays: Object.entries(calendarSettings.openingHours || {})
          .filter(([_, hours]) => hours?.enabled)
          .map(([day]) => day),
        shiftPattern: calendarSettings.shiftPattern,
      });
    }
  }, [calendarSettings]);

  // Calculate earliest opening time from calendar settings for minTime/scrollTime
  const getEarliestOpeningTime = useCallback(() => {
    if (!calendarSettings?.openingHours) {
      // Default to 7:00 AM if no settings
      return new Date(2020, 0, 1, 7, 0, 0);
    }
    
    const openingHours = calendarSettings.openingHours;
    let earliestHour = 7; // Default to 7:00 AM
    let earliestMinute = 0;
    
    // Find the earliest opening time across all enabled days
    Object.values(openingHours).forEach((hours) => {
      if (hours?.enabled && hours?.open) {
        const [hour, minute] = hours.open.split(':').map(Number);
        const hourInMinutes = hour * 60 + minute;
        const earliestInMinutes = earliestHour * 60 + earliestMinute;
        
        if (hourInMinutes < earliestInMinutes) {
          earliestHour = hour;
          earliestMinute = minute;
        }
      }
    });
    
    return new Date(2020, 0, 1, earliestHour, earliestMinute, 0);
  }, [calendarSettings]);
  const [pendingRecurringAction, setPendingRecurringAction] = useState<{
    type: 'delete' | 'move';
    event: CalendarEvent;
    newStart?: Date;
    newEnd?: Date;
  } | null>(null);
  const [smartMatches, setSmartMatches] = useState<SmartMatch[]>([]);
  const [isCalculatingMatches, setIsCalculatingMatches] = useState(false);
  // Optimistic updates: Track newly created shifts locally until parent refetches
  const [optimisticShifts, setOptimisticShifts] = useState<CalendarEvent[]>([]);
  // Track selected professional for invite flow
  const [selectedProfessional, setSelectedProfessional] = useState<Professional | null>(null);
  const [showInviteSearch, setShowInviteSearch] = useState(false);
  const [inviteSearchQuery, setInviteSearchQuery] = useState("");
  
  // Favorites management - stored in localStorage keyed by user ID
  const getFavoritesKey = useCallback(() => {
    return `favorite-professionals-${user?.id || 'default'}`;
  }, [user?.id]);
  
  const [favoriteIds, setFavoriteIds] = useState<string[]>(() => {
    if (typeof window === 'undefined') return [];
    try {
      const key = `favorite-professionals-${user?.id || 'default'}`;
      const stored = localStorage.getItem(key);
      return stored ? JSON.parse(stored) : [];
    } catch {
      return [];
    }
  });
  
  // Save favorites to localStorage whenever they change
  useEffect(() => {
    if (typeof window !== 'undefined') {
      try {
        const key = getFavoritesKey();
        localStorage.setItem(key, JSON.stringify(favoriteIds));
      } catch (error) {
        console.error('Failed to save favorites:', error);
      }
    }
    // getFavoritesKey is stable (only changes when user?.id changes), so we don't need it in deps
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [favoriteIds]);
  
  // Reload favorites when user changes
  useEffect(() => {
    if (typeof window !== 'undefined') {
      try {
        const key = getFavoritesKey();
        const stored = localStorage.getItem(key);
        if (stored) {
          setFavoriteIds(JSON.parse(stored));
        } else {
          setFavoriteIds([]);
        }
      } catch {
        setFavoriteIds([]);
      }
    }
    // Only depend on user?.id - getFavoritesKey is already memoized and will update when user?.id changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [user?.id]);
  
  const toggleFavorite = (professionalId: string) => {
    setFavoriteIds(prev => {
      if (prev.includes(professionalId)) {
        return prev.filter(id => id !== professionalId);
      } else {
        return [...prev, professionalId];
      }
    });
  };
  
  const isFavorite = (professionalId: string) => favoriteIds.includes(professionalId);
  
  const { data: professionalsRaw = [] } = useQuery<ProfessionalListItem[]>({
    queryKey: ['professionals', user?.id],
    queryFn: () => fetchProfessionals({ limit: 200, offset: 0 }),
    enabled: mode === 'business' && !!user?.id,
  });

  const allProfessionals: Professional[] = useMemo(() => {
    return (professionalsRaw || []).map((p) => ({
      id: p.id,
      name: p.name,
      displayName: p.name,
      email: p.email,
      avatar: p.avatarUrl ?? undefined,
      photoURL: p.avatarUrl ?? undefined,
      rating: p.averageRating ?? undefined,
      skills: [],
    }));
  }, [professionalsRaw]);
  
  // Filter and sort professionals: favorites first, then by search query
  const filteredProfessionals = useMemo(() => {
    let filtered = allProfessionals;
    
    // Filter by search query if provided
    if (inviteSearchQuery.trim()) {
      const query = inviteSearchQuery.toLowerCase();
      filtered = allProfessionals.filter((prof) => {
        const nameMatch = prof.name.toLowerCase().includes(query) ||
          prof.displayName?.toLowerCase().includes(query);
        const skillMatch = prof.skills?.some((skill) =>
          skill.toLowerCase().includes(query)
        );
        return nameMatch || skillMatch;
      });
    }
    
    // Sort: favorites first, then by rating (highest first)
    return [...filtered].sort((a, b) => {
      const aIsFavorite = isFavorite(a.id);
      const bIsFavorite = isFavorite(b.id);
      
      // Favorites come first
      if (aIsFavorite && !bIsFavorite) return -1;
      if (!aIsFavorite && bIsFavorite) return 1;
      
      // Then sort by rating (highest first)
      const aRating = a.rating || 0;
      const bRating = b.rating || 0;
      return bRating - aRating;
    });
  }, [inviteSearchQuery, favoriteIds, allProfessionals]);
  
  // Separate favorites from others for display
  const favoriteProfessionals = useMemo(() => {
    return filteredProfessionals.filter(prof => isFavorite(prof.id));
  }, [filteredProfessionals, favoriteIds]);
  
  const otherProfessionals = useMemo(() => {
    return filteredProfessionals.filter(prof => !isFavorite(prof.id));
  }, [filteredProfessionals, favoriteIds]);
  
  const getInitials = (name: string) => {
    return name
      .split(' ')
      .map((n) => n[0])
      .join('')
      .toUpperCase()
      .slice(0, 2);
  };

  // Update current time every second for smooth time indicator movement
  useEffect(() => {
    const interval = setInterval(() => {
      setCurrentTime(new Date());
    }, 1000); // Update every second for smooth movement
    return () => clearInterval(interval);
  }, []);

  // Mobile Squeeze fix: Dynamically switch view based on window size
  // Only switch on initial mount and when window size crosses the mobile threshold
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const isMobile = window.innerWidth < 768;
    const currentViewIsMobileUnfriendly = view === 'month';
    
    // Only auto-switch if we're in an unreadable view for the current screen size
    // Don't force switch if user has manually selected a view
    if (isMobile && currentViewIsMobileUnfriendly) {
      setView('day');
    }
  }, []); // Only run on mount - let user manually switch views after that

  // Convert bookings to calendar events and merge with optimistic updates
  const events: CalendarEvent[] = useMemo(() => {
    // Defensive check: ensure bookings is always an array
    const bookingsArray = bookings && Array.isArray(bookings) ? bookings : [];
    
    // Start with optimistic shifts (newly created, not yet in bookings)
    const optimisticEvents: CalendarEvent[] = optimisticShifts;

    if (bookingsArray.length === 0) {
      return optimisticEvents;
    }

    try {
      const bookingEvents = bookingsArray
        .map((booking: any) => {
          // Skip invalid bookings
          if (!booking || typeof booking !== 'object') return null;

          try {
            const job = booking.job || booking.shift;
            if (!job) return null;

            // Determine date from job/shift
            const dateStr = job.date || job.startTime || booking.appliedAt;
            if (!dateStr) return null;

            const startDate = new Date(dateStr);
            if (isNaN(startDate.getTime())) return null;

            // Determine end date (default to 8 hours later if not specified)
            let endDate: Date;
            if (job.endTime) {
              endDate = new Date(job.endTime);
              // Validate endDate
              if (isNaN(endDate.getTime())) {
                endDate = new Date(startDate.getTime() + 8 * 60 * 60 * 1000);
              }
            } else {
              endDate = new Date(startDate.getTime() + 8 * 60 * 60 * 1000);
            }

            // Ensure endDate is after startDate
            if (endDate <= startDate) {
              endDate = new Date(startDate.getTime() + 8 * 60 * 60 * 1000);
            }

            // Determine status - support draft, invited, confirmed, pending, completed, past
            let status: "draft" | "invited" | "confirmed" | "pending" | "completed" | "past";
            if (isPast(endDate) && !isToday(endDate)) {
              status = "past";
            } else if (job.status === "draft") {
              status = "draft";
            } else if (job.status === "invited") {
              status = "invited";
            } else if (booking.status === "accepted" || booking.status === "confirmed" || job.status === "filled") {
              status = "confirmed";
            } else if (booking.status === "completed" || job.status === "completed") {
              status = "completed";
            } else {
              status = "pending";
            }

            // Include assignedStaff if available
            const assignedStaff = job.assignedStaff || booking.assignedStaff || null;
            
            // Ghost Shift fix: Ensure title has proper fallback even if job.title is null/undefined/empty
            const eventTitle = job?.title || 
                              (job?.shift?.title) || 
                              (booking?.shift?.title) || 
                              (booking?.job?.title) || 
                              "Untitled Shift";
            
            return {
              id: booking.id || job.id || `event-${Date.now()}-${Math.random()}`,
              title: eventTitle,
              start: startDate,
              end: endDate,
              resource: {
                booking: {
                  ...booking,
                  shift: booking.shift ? {
                    ...booking.shift,
                    assignedStaff,
                  } : undefined,
                  job: booking.job ? {
                    ...booking.job,
                    assignedStaff,
                  } : undefined,
                },
                status,
                type: booking.job ? "job" : "shift",
              },
            } as CalendarEvent;
          } catch (error) {
            // Log error but don't crash - skip this booking
            console.warn('Error processing booking:', error, booking);
            return null;
          }
        })
        .filter((event): event is CalendarEvent => event !== null);
      
      // Merge booking events with optimistic events, avoiding duplicates
      const bookingEventIds = new Set(bookingEvents.map(e => e.id));
      const uniqueOptimisticEvents = optimisticEvents.filter(e => !bookingEventIds.has(e.id));
      
      const allRealEvents = [...bookingEvents, ...uniqueOptimisticEvents];
      
      // Generate auto-slots if in business mode and settings are configured
      if (mode === 'business' && calendarSettings) {
        // Calculate date range based on current view
        let rangeStart: Date;
        let rangeEnd: Date;
        
        if (view === 'month') {
          // Show slots for current month
          rangeStart = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
          rangeEnd = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
        } else if (view === 'week') {
          rangeStart = startOfWeek(currentDate, { weekStartsOn: 0 });
          rangeEnd = endOfWeek(currentDate, { weekStartsOn: 0 });
        } else {
          // Day view - show current day
          rangeStart = new Date(currentDate);
          rangeEnd = new Date(currentDate);
        }
        
        // Generate slots for the range
        const generatedSlots = generateShiftSlotsForRange(rangeStart, rangeEnd, calendarSettings);
        console.log('[CALENDAR] Generated slots:', {
          count: generatedSlots.length,
          range: { start: rangeStart, end: rangeEnd },
          settings: calendarSettings,
          slots: generatedSlots.slice(0, 5), // Log first 5 slots
        });
        
        // Filter out slots that overlap with existing shifts
        const existingShifts = allRealEvents.map(e => ({ start: e.start, end: e.end }));
        const availableSlots = filterOverlappingSlots(generatedSlots, existingShifts);
        console.log('[CALENDAR] Available slots after filtering:', {
          total: generatedSlots.length,
          available: availableSlots.length,
          filtered: generatedSlots.length - availableSlots.length,
        });
        
        // Convert generated slots to calendar events
        const autoSlotEvents: CalendarEvent[] = availableSlots.map(slot => {
          let title = 'Unassigned Slot';
          if (slot.pattern === 'half-day') {
            title = slot.slotIndex === 0 ? 'Morning Shift (Unassigned)' : 'Afternoon Shift (Unassigned)';
          } else if (slot.pattern === 'thirds') {
            const labels = ['Morning Shift (Unassigned)', 'Afternoon Shift (Unassigned)', 'Close Shift (Unassigned)'];
            title = labels[slot.slotIndex] || 'Unassigned Slot';
          } else if (slot.pattern === 'full-day') {
            title = 'Full Day Shift (Unassigned)';
          }
          
          return {
            id: slot.id,
            title,
            start: slot.start,
            end: slot.end,
            resource: {
              status: 'unassigned' as const,
              type: 'auto-slot' as const,
              isAutoGenerated: true,
              generatedSlot: slot,
            },
          };
        });
        
        return [...allRealEvents, ...autoSlotEvents];
      }
      
      return allRealEvents;
    } catch (error) {
      // If entire conversion fails, return optimistic events only
      console.error('Error converting bookings to events:', error);
      return optimisticEvents;
    }
  }, [bookings, optimisticShifts, calendarSettings, mode, view, currentDate]);

  // Filter events based on status
  const filteredEvents = useMemo(() => {
    // Defensive check: ensure events is always an array
    if (!events || !Array.isArray(events)) {
      return [];
    }
    
    if (statusFilter === "all") return events;
    
    try {
      return events.filter((event) => {
        if (!event || !event.resource) return false;
        if (statusFilter === "pending") return event.resource.status === "pending";
        if (statusFilter === "confirmed") return event.resource.status === "confirmed";
        if (statusFilter === "completed") return event.resource.status === "completed";
        return true;
      });
    } catch (error) {
      // If filtering fails, return empty array to prevent crash
      console.error('Error filtering events:', error);
      return [];
    }
  }, [events, statusFilter]);

  // Event style getter with Traffic Light color system
  // Green: Confirmed (Worker is locked in)
  // Yellow: Open (Posted, waiting for applicants)
  // Grey: Draft/Unposted or Past
  const eventStyleGetter = useCallback(
    (event: CalendarEvent) => {
      // Defensive check: ensure event and resource exist
      if (!event || !event.resource) {
        return {
          style: {
            backgroundColor: "#3f3f46", // zinc-700 - Default (Draft/Unknown)
            borderRadius: "6px",
            opacity: 0.9,
            color: "white",
            border: "0px",
            display: "block",
          },
        };
      }

      const shift = event.resource?.booking?.shift || event.resource?.booking?.job;
      const status = event.resource.status || shift?.status || "DRAFT";
      const isAssigned = !!(shift?.assignedStaff || shift?.assignedStaffId || shift?.workerId);
      
      // Check if event is in the past
      const now = new Date();
      const isPastEvent = event.end < now && !isToday(event.end);
      
      let backgroundColor = "#3f3f46"; // Default (Zinc-700) - Draft/Unknown

      // Traffic Light System:
      let borderStyle = "0px";
      let borderColor = "transparent";
      
      // Auto-generated unassigned slots - ghost style with dashed border
      if (event.resource.isAutoGenerated && status === "unassigned") {
        backgroundColor = "rgba(59, 130, 246, 0.1)"; // Very low opacity blue
        borderStyle = "2px dashed";
        borderColor = "#3b82f6"; // blue-500
      } else if (isAssigned) {
        // GREEN: Confirmed/Working - Worker is locked in
        backgroundColor = "#10b981"; // emerald-500
      } else if (status === "invited" || (status === "pending" && !isAssigned)) {
        // GREY (Ghost Slot): Pending invitation - Dashed border to show it's "not real" yet
        backgroundColor = "#d4d4d8"; // zinc-300 (Light Grey)
        borderStyle = "2px dashed";
        borderColor = "#71717a"; // zinc-500
      } else if (status === "PUBLISHED" || status === "OPEN" || status === "open") {
        // YELLOW: Open/Hiring - Posted, waiting for applicants
        backgroundColor = "#eab308"; // yellow-500
      } else if (isPastEvent) {
        // GREY: Past events
        backgroundColor = "#71717a"; // zinc-500
      } else if (status === "draft" || status === "DRAFT") {
        // GREY: Draft/Unposted
        backgroundColor = "#71717a"; // zinc-500
      }

      // Auto-generated slots have different styling
      const isAutoSlot = event.resource.isAutoGenerated && status === "unassigned";
      const isConfirmed = isAssigned && (status === "confirmed" || status === "filled");
      
      return {
        style: {
          backgroundColor,
          borderRadius: "6px",
          opacity: isAutoSlot ? 1 : (status === "invited" || status === "pending") ? 0.7 : (isPastEvent ? 0.6 : 0.9),
          color: isAutoSlot ? "#3b82f6" : (status === "invited" || status === "pending") ? "#3f3f46" : "white",
          border: borderStyle,
          borderColor: borderColor,
          display: "block",
          cursor: isAutoSlot ? "pointer" : "default",
          boxShadow: isConfirmed ? "0 2px 4px rgba(0, 0, 0, 0.15)" : "none",
          padding: "8px 12px", // Add padding for better text spacing
        },
      };
    },
    []
  );

  // Handle event click
  const handleSelectEvent = useCallback((event: CalendarEvent) => {
    // Defensive check: ensure event exists
    if (!event) return;
    
    // If it's an auto-generated unassigned slot, open new shift assignment modal
    if (mode === 'business' && event.resource?.isAutoGenerated && event.resource?.status === 'unassigned') {
      // Prevent scheduling actions on past slots (but still render them for visibility)
      if (isPast(event.start) && !isToday(event.start)) {
        toast({
          title: "Past slot",
          description: "You canâ€™t assign or post a shift for a past time slot.",
          variant: "destructive",
        });
        return;
      }
      setSelectedUnassignedSlot({ start: event.start, end: event.end });
      setShowShiftAssignmentModal(true);
      return;
    }
    
    // Legacy: If it's an auto-generated slot with generatedSlot property, use old modal
    if (mode === 'business' && event.resource?.isAutoGenerated && event.resource?.generatedSlot) {
      setSelectedAutoSlot(event.resource.generatedSlot);
      setShowAutoSlotAssignment(true);
      return;
    }
    
    // If it's a draft shift in business mode, open AssignStaffModal
    if (mode === 'business' && event.resource?.status === 'draft') {
      setSelectedShiftForAssignment(event);
      setShowAssignStaffModal(true);
      return;
    }
    
    // Otherwise, show event details
    setSelectedEvent(event);
    setShowEventDetails(true);
  }, [mode, toast]);

  // Helper function to get shift times based on settings
  const getShiftTimesFromSettings = useCallback((date: Date, pattern?: ShiftPattern) => {
    if (!calendarSettings || !pattern) {
      // Default: use selected slot times
      return null;
    }

    const dayOfWeek = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'][date.getDay()];
    const dayHours = calendarSettings.openingHours[dayOfWeek];
    
    if (!dayHours || !dayHours.enabled) {
      return null;
    }

    const [openHour, openMin] = dayHours.open.split(':').map(Number);
    const [closeHour, closeMin] = dayHours.close.split(':').map(Number);
    
    const openTime = new Date(date);
    openTime.setHours(openHour, openMin, 0, 0);
    
    const closeTime = new Date(date);
    closeTime.setHours(closeHour, closeMin, 0, 0);
    
    const totalMinutes = (closeTime.getTime() - openTime.getTime()) / (1000 * 60);
    
    switch (pattern) {
      case 'half-day': {
        const midPoint = totalMinutes / 2;
        const midTime = new Date(openTime.getTime() + midPoint * 60 * 1000);
        return {
          start: openTime,
          end: midTime,
        };
      }
      case 'thirds': {
        const third = totalMinutes / 3;
        const firstThird = new Date(openTime.getTime() + third * 60 * 1000);
        return {
          start: openTime,
          end: firstThird,
        };
      }
      case 'custom': {
        const shiftLength = (calendarSettings.defaultShiftLength || 8) * 60; // Convert to minutes
        const endTime = new Date(openTime.getTime() + shiftLength * 60 * 1000);
        return {
          start: openTime,
          end: endTime > closeTime ? closeTime : endTime,
        };
      }
      case 'full-day':
      default:
        return {
          start: openTime,
          end: closeTime,
        };
    }
  }, [calendarSettings]);

  // Handle slot click (for quick event creation)
  const handleSelectSlot = useCallback(
    ({ start, end }: { start: Date; end: Date }) => {
      // Validate dates
      if (!start || !end || isNaN(start.getTime()) || isNaN(end.getTime())) {
        console.warn('[CALENDAR] Invalid slot selection - dates are invalid');
        return;
      }
      
      // Prevent selecting dates in the past (Time Travel Bug fix)
      const now = new Date();
      const startOfDay = new Date(start);
      startOfDay.setHours(0, 0, 0, 0);
      const nowStartOfDay = new Date(now);
      nowStartOfDay.setHours(0, 0, 0, 0);
      
      if (startOfDay < nowStartOfDay) {
        toast({
          title: "Cannot create shifts in the past",
          description: "Please select a date from today onwards.",
          variant: "destructive",
        });
        return;
      }
      
      // Try to use settings-based times if available
      let shiftTimes = null;
      if (calendarSettings && mode === 'business') {
        shiftTimes = getShiftTimesFromSettings(start, calendarSettings.shiftPattern);
      }
      
      // Use settings times if available, otherwise use selected slot
      const finalStart = shiftTimes?.start || start;
      const finalEnd = shiftTimes?.end || (end > start ? end : new Date(start.getTime() + 60 * 60 * 1000));
      
      setSelectedSlot({ start: finalStart, end: finalEnd });
      setSelectedDate(start);
      setNewEventTitle(""); // Reset title
      // Initialize form data with calculated times
      setShiftFormData({
        title: "",
        description: "",
        date: format(start, "yyyy-MM-dd"),
        startTime: format(finalStart, "HH:mm"),
        endTime: format(finalEnd, "HH:mm"),
        hourlyRate: "45",
        location: "",
      });
      setShowCreateModal(true);
      
      if (onDateSelect) {
        onDateSelect(start);
      }
    },
    [onDateSelect, toast, calendarSettings, mode, getShiftTimesFromSettings]
  );

  // Handle date change from mini calendar
  const handleMiniCalendarSelect = useCallback((date: Date | undefined) => {
    if (date && !isNaN(date.getTime())) {
      setCurrentDate(date);
      setSelectedDate(date);
    }
  }, []);

  // Handle navigation from react-big-calendar (receives Date object)
  const handleNavigate = useCallback((newDate: Date | string) => {
    try {
      // Handle both Date objects and date strings
      const date = newDate instanceof Date ? newDate : new Date(newDate);
      
      // Validate date
      if (!date || isNaN(date.getTime())) {
        console.warn('[CALENDAR] Invalid date in handleNavigate:', newDate);
        return;
      }
      
      // Ensure date is within reasonable bounds (not too far in past/future)
      const minDate = new Date(1900, 0, 1);
      const maxDate = new Date(2100, 11, 31);
      
      if (date < minDate || date > maxDate) {
        console.warn('[CALENDAR] Date out of bounds in handleNavigate:', date);
        return;
      }
      
      setCurrentDate(date);
      
      // Update selected date if it's not set or if navigating to a different day
      if (!selectedDate || !isSameDay(date, selectedDate)) {
        setSelectedDate(date);
      }
    } catch (error) {
      console.error('[CALENDAR] Error in handleNavigate:', error);
    }
  }, [selectedDate]);

  // Handle view change from react-big-calendar
  const handleViewChange = useCallback((newView: View | string) => {
    try {
      // Validate view
      const validViews: View[] = ['month', 'week', 'day', 'agenda'];
      if (!newView || !validViews.includes(newView as View)) {
        console.warn('[CALENDAR] Invalid view in handleViewChange:', newView);
        return;
      }
      
      const viewToSet = newView as View;
      
      // When switching views, ensure currentDate is valid for the new view
      // Adjust date if necessary (e.g., when switching to week view, ensure we're at start of week)
      let adjustedDate = currentDate;
      
      if (viewToSet === 'week') {
        // Adjust to start of week
        adjustedDate = startOfWeek(currentDate, { weekStartsOn: 0 });
      } else if (viewToSet === 'day') {
        // For day view, just use the current date
        adjustedDate = currentDate;
      } else if (viewToSet === 'month') {
        // For month view, ensure we're at the start of the month
        adjustedDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
      }
      
      // Validate adjusted date
      if (adjustedDate && !isNaN(adjustedDate.getTime())) {
        setCurrentDate(adjustedDate);
        if (!selectedDate || !isSameDay(adjustedDate, selectedDate)) {
          setSelectedDate(adjustedDate);
        }
      }
      
      setView(viewToSet);
    } catch (error) {
      console.error('[CALENDAR] Error in handleViewChange:', error);
    }
  }, [currentDate, selectedDate]);

  // Navigate calendar (for custom buttons)
  const navigate = useCallback((action: "PREV" | "NEXT" | "TODAY") => {
    try {
      if (action === "TODAY") {
        const today = new Date();
        if (!isNaN(today.getTime())) {
          setCurrentDate(today);
          setSelectedDate(today);
        }
        return;
      }

      const newDate = new Date(currentDate);
      
      // Validate current date first
      if (isNaN(newDate.getTime())) {
        console.warn('[CALENDAR] Invalid currentDate in navigate, resetting to today');
        const today = new Date();
        setCurrentDate(today);
        setSelectedDate(today);
        return;
      }
      
      // Navigate based on current view
      if (view === "month") {
        newDate.setMonth(
          action === "PREV" ? newDate.getMonth() - 1 : newDate.getMonth() + 1
        );
      } else if (view === "week") {
        // Navigate by weeks, maintaining day of week
        newDate.setDate(action === "PREV" ? newDate.getDate() - 7 : newDate.getDate() + 7);
      } else if (view === "day") {
        // Navigate by days
        newDate.setDate(action === "PREV" ? newDate.getDate() - 1 : newDate.getDate() + 1);
      }
      
      // Validate the new date before setting
      if (!isNaN(newDate.getTime())) {
        setCurrentDate(newDate);
        // Update selected date if navigating to a different day
        if (!selectedDate || !isSameDay(newDate, selectedDate)) {
          setSelectedDate(newDate);
        }
      } else {
        console.warn('[CALENDAR] Invalid newDate after navigation calculation');
      }
    } catch (error) {
      console.error('[CALENDAR] Error in navigate:', error);
    }
  }, [currentDate, view, selectedDate]);

  // Get date range for display based on current view
  const dateRange = useMemo(() => {
    if (view === "week") {
      const weekStart = startOfWeek(currentDate, { weekStartsOn: 0 });
      const weekEnd = endOfWeek(currentDate, { weekStartsOn: 0 });
      return { start: weekStart, end: weekEnd };
    } else if (view === "day") {
      return { start: currentDate, end: currentDate };
    } else if (view === "month") {
      const monthStart = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
      const monthEnd = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
      return { start: monthStart, end: monthEnd };
    }
    return null;
  }, [currentDate, view]);

  // Smart Fill handlers
  const handleSmartFillClick = useCallback(async () => {
    if (!dateRange || mode !== 'business') {
      toast({
        title: "Smart Fill Unavailable",
        description: "Smart Fill is only available in business mode.",
        variant: "destructive",
      });
      return;
    }

    if (!user?.id) {
      toast({
        title: "Error",
        description: "Please log in to use Smart Fill.",
        variant: "destructive",
      });
      return;
    }

    if (!calendarSettings) {
      toast({
        title: "Calendar Settings Required",
        description: "Please configure your opening hours and shift pattern in Calendar Settings first.",
        variant: "destructive",
      });
      return;
    }

    setIsCalculatingMatches(true);
    try {
      // Get favorite professional IDs from localStorage
      const favoritesKey = `favorite-professionals-${user.id}`;
      const storedFavorites = typeof window !== 'undefined' 
        ? localStorage.getItem(favoritesKey) 
        : null;
      const favoriteIds: string[] = storedFavorites ? JSON.parse(storedFavorites) : [];

      // Call the smart-fill endpoint
      const response = await apiRequest("POST", "/api/shifts/smart-fill", {
        startDate: dateRange.start.toISOString(),
        endDate: dateRange.end.toISOString(),
        shopId: user.id,
        actionType: 'post_to_board', // Default to posting to board
        calendarSettings: {
          openingHours: calendarSettings.openingHours,
          shiftPattern: calendarSettings.shiftPattern,
          defaultShiftLength: calendarSettings.defaultShiftLength,
        },
        favoriteProfessionalIds: favoriteIds.length > 0 ? favoriteIds : undefined,
        defaultHourlyRate: shiftFormData.hourlyRate || "45",
        defaultLocation: shiftFormData.location || undefined,
      });

      const result = await response.json();

      // Invalidate queries to refresh the calendar
      queryClient.invalidateQueries({ queryKey: ["/api/shifts"] });
      queryClient.invalidateQueries({ queryKey: ["shop-shifts"] });

      if (result.success) {
        toast({
          title: "Smart Fill Complete",
          description: result.message || `${result.count} shifts posted successfully.`,
        });
      } else {
        toast({
          title: "Smart Fill Failed",
          description: result.message || "Failed to process Smart Fill. Please try again.",
          variant: "destructive",
        });
      }
    } catch (error: any) {
      console.error("Error in Smart Fill:", error);
      toast({
        title: "Error",
        description: error?.message || "Failed to process Smart Fill. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsCalculatingMatches(false);
    }
  }, [dateRange, mode, user, calendarSettings, toast, shiftFormData, queryClient]);

  const handleSendInvites = useCallback(async () => {
    const matchesToSend = smartMatches.filter((m) => m.suggestedCandidate !== null);
    
    if (matchesToSend.length === 0) {
      return;
    }

    try {
      // Update each shift status from DRAFT to INVITED
      for (const match of matchesToSend) {
        try {
          await apiRequest('PATCH', `/api/shifts/${match.shiftId}`, { 
            status: 'invited'
          });
          
          // TODO: Trigger notification to the professional
          // This would typically be done via a separate endpoint or notification service
        } catch (error) {
          console.error(`Failed to update shift ${match.shiftId}:`, error);
        }
      }

      // Invalidate queries to refresh the calendar
      queryClient.invalidateQueries({ queryKey: ['shop-shifts'] });
      queryClient.invalidateQueries({ queryKey: ['/api/shifts'] });

      toast({
        title: "Invites Sent",
        description: `Successfully sent ${matchesToSend.length} invite${matchesToSend.length !== 1 ? 's' : ''}.`,
      });

      // Add notification
      addNotification('success', `Invites sent successfully to ${matchesToSend.length} candidate${matchesToSend.length !== 1 ? 's' : ''}`);

      setShowSmartFillModal(false);
    } catch (error) {
      console.error("Error sending invites:", error);
      toast({
        title: "Error",
        description: "Failed to send some invites. Please try again.",
        variant: "destructive",
      });
    }
  }, [smartMatches, queryClient, toast, addNotification]);

  // Custom toolbar component (returns null to hide default toolbar)
  const customToolbar = useCallback(() => null, []);
  
  // Custom header component - Clean and minimal design
  const customHeader = useCallback(
    ({ date, localizer, label }: { date: Date; localizer: any; label: string }) => {
      const isCurrentDay = isSameDay(date, new Date());
      const dayOfWeek = date.getDay(); // 0 = Sunday, 6 = Saturday
      const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
      
      // Format: Day name (e.g., "Mon") and Date (e.g., "12")
      const dayName = format(date, 'EEE', { locale: enUS });
      const dayNumber = format(date, 'dd');
      
      return (
        <div
          className={`rbc-header ${isCurrentDay ? "rbc-header-today" : ""} ${isWeekend ? "rbc-header-weekend" : ""}`}
        >
          <div className={`text-xs uppercase font-semibold ${isCurrentDay ? "text-foreground" : "text-muted-foreground"}`}>
            {dayName}
          </div>
          <div className={`text-xl font-bold ${isCurrentDay ? "text-foreground" : "text-muted-foreground"}`}>
            {dayNumber}
          </div>
        </div>
      );
    },
    []
  );

  // Create event/availability mutation - uses shifts endpoint for availability slots
  const createEventMutation = useMutation({
    mutationFn: async (data: { title: string; start: Date; end: Date; description?: string; hourlyRate?: string; location?: string; professional?: Professional | null }) => {
      // Use shifts endpoint with proper data structure matching ShiftSchema
      // Note: hourlyRate is required by the database, so we provide a default
      // In business mode, create as 'open' (full shift). In professional mode, use 'open'
      // If professional is provided, create as 'invited' status
      const defaultStatus = data.professional ? 'invited' : (mode === 'business' ? 'open' : 'open');
      const payload: any = {
        title: data.title || (mode === 'business' ? "New Shift" : "Availability"),
        description: data.description || (mode === 'business' ? "Shift slot" : "Availability slot"),
        startTime: data.start.toISOString(),
        endTime: data.end.toISOString(),
        hourlyRate: data.hourlyRate || "45",
        location: data.location || "",
        status: defaultStatus,
      };
      
      // If professional is provided, add assigned staff info
      if (data.professional) {
        payload.assignedStaffId = data.professional.id;
        payload.assignedStaff = {
          id: data.professional.id,
          name: data.professional.name,
          displayName: data.professional.displayName,
          email: data.professional.email,
          photoURL: data.professional.photoURL || data.professional.avatar,
        };
      }
      
      const response = await apiRequest("POST", "/api/shifts", payload);
      return response.json();
    },
    onSuccess: (newShift, variables) => {
      // CRITICAL: Add to optimistic state immediately so it appears on calendar
      const startDate = new Date(newShift.startTime || newShift.start);
      const endDate = new Date(newShift.endTime || newShift.end);
      const hasProfessional = !!variables.professional;
      
      const optimisticEvent: CalendarEvent = {
        id: newShift.id,
        title: newShift.title || "New Shift",
        start: startDate,
        end: endDate,
        resource: {
          booking: {
            shift: {
              id: newShift.id,
              title: newShift.title,
              startTime: newShift.startTime,
              endTime: newShift.endTime,
              status: newShift.status || (hasProfessional ? 'invited' : 'open'),
              hourlyRate: newShift.hourlyRate,
              location: newShift.location,
              assignedStaff: variables.professional ? {
                id: variables.professional.id,
                name: variables.professional.name,
                displayName: variables.professional.displayName,
                email: variables.professional.email,
                photoURL: variables.professional.photoURL || variables.professional.avatar,
              } : null,
            },
          },
          status: hasProfessional ? 'invited' : 'pending',
          type: 'shift',
        },
      };
      
      setOptimisticShifts(prev => [...prev, optimisticEvent]);
      
      // Invalidate both applications and shifts queries to refresh calendar (background refetch)
      queryClient.invalidateQueries({ queryKey: ["/api/applications"] });
      queryClient.invalidateQueries({ queryKey: ["/api/shifts"] });
      queryClient.invalidateQueries({ queryKey: ["shop-shifts"] });
      
      toast({
        title: mode === 'business' ? "Shift created" : "Event created",
        description: variables.professional
          ? `Shift created and invite sent to ${variables.professional.name}!`
          : mode === 'business' 
            ? "Your shift has been created successfully."
            : "Your availability slot has been created successfully",
      });
      
      setShowCreateModal(false);
      setSelectedSlot(null);
      setNewEventTitle("");
      setSelectedProfessional(null);
      setShowInviteSearch(false);
      // Reset form data
      setShiftFormData({
        title: "",
        description: "",
        date: "",
        startTime: "09:00",
        endTime: "17:00",
        hourlyRate: "45",
        location: "",
      });
      
      // Clear optimistic shift after parent refetches (with a delay to ensure smooth transition)
      setTimeout(() => {
        setOptimisticShifts(prev => prev.filter(e => e.id !== newShift.id));
      }, 2000);
    },
    onError: (error: any) => {
      toast({
        title: "Failed to create event",
        description: error?.message || "Please try again later",
        variant: "destructive",
      });
    },
  });

  // Update event mutation for drag-and-drop and resize
  const updateEventMutation = useMutation({
    mutationFn: async (data: { id: string; start: Date; end: Date }) => {
      // Try to update via PUT endpoint (full update) or PATCH if PUT doesn't exist
      try {
        const response = await apiRequest("PUT", `/api/shifts/${data.id}`, {
          startTime: data.start.toISOString(),
          endTime: data.end.toISOString(),
        });
        return response.json();
      } catch (error: any) {
        // Fallback: if PUT doesn't work, we might need to handle this differently
        // For now, we'll throw the error and handle it in onError
        throw error;
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/applications"] });
      queryClient.invalidateQueries({ queryKey: ["/api/shifts"] });
      toast({
        title: "Event updated",
        description: "Shift has been rescheduled successfully",
      });
    },
    onError: (error: any) => {
      toast({
        title: "Failed to update event",
        description: error?.message || "Please try again later",
        variant: "destructive",
      });
    },
  });

  // Assign staff to shift mutation
  const assignStaffMutation = useMutation({
    mutationFn: async (data: { shiftId: string; professional: Professional }) => {
      const response = await apiRequest("PUT", `/api/shifts/${data.shiftId}`, {
        status: "invited",
        assignedStaffId: data.professional.id,
        assignedStaff: {
          id: data.professional.id,
          name: data.professional.name,
          displayName: data.professional.displayName,
          email: data.professional.email,
          photoURL: data.professional.photoURL || data.professional.avatar,
        },
      });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/shifts"] });
      queryClient.invalidateQueries({ queryKey: ["/api/applications"] });
      toast({
        title: "Staff invited",
        description: "An invitation has been sent to the selected professional",
      });
      setShowAssignStaffModal(false);
      setSelectedShiftForAssignment(null);
    },
    onError: (error: any) => {
      toast({
        title: "Failed to assign staff",
        description: error?.message || "Please try again later",
        variant: "destructive",
      });
    },
  });

  // Handle staff assignment
  const handleAssignStaff = useCallback((professional: Professional) => {
    if (!selectedShiftForAssignment) return;
    assignStaffMutation.mutate({
      shiftId: selectedShiftForAssignment.id,
      professional,
    });
  }, [selectedShiftForAssignment, assignStaffMutation]);

  // Handle assignment from auto-generated slot
  const handleAutoSlotAssign = useCallback(async (professional: Professional) => {
    if (!selectedAutoSlot) return;

    try {
      // Create a new shift with the professional assigned
      const response = await apiRequest("POST", "/api/shifts", {
        title: `Shift - ${professional.name}`,
        description: `Assigned shift for ${professional.name}`,
        startTime: selectedAutoSlot.start.toISOString(),
        endTime: selectedAutoSlot.end.toISOString(),
        hourlyRate: shiftFormData.hourlyRate || "45",
        location: shiftFormData.location || "",
        status: "invited",
        assignedStaffId: professional.id,
        assignedStaff: {
          id: professional.id,
          name: professional.name,
          displayName: professional.displayName,
          email: professional.email,
          photoURL: professional.photoURL || professional.avatar,
        },
      });

      const newShift = await response.json();

      // Add to optimistic state immediately
      const optimisticEvent: CalendarEvent = {
        id: newShift.id,
        title: newShift.title || `Shift - ${professional.name}`,
        start: selectedAutoSlot.start,
        end: selectedAutoSlot.end,
        resource: {
          booking: {
            shift: {
              id: newShift.id,
              title: newShift.title,
              startTime: newShift.startTime,
              endTime: newShift.endTime,
              status: "invited",
              hourlyRate: newShift.hourlyRate,
              location: newShift.location,
              assignedStaff: {
                id: professional.id,
                name: professional.name,
                displayName: professional.displayName,
                email: professional.email,
                photoURL: professional.photoURL || professional.avatar,
              },
            },
          },
          status: 'invited',
          type: 'shift',
        },
      };

      setOptimisticShifts(prev => [...prev, optimisticEvent]);

      // Invalidate queries
      queryClient.invalidateQueries({ queryKey: ["/api/shifts"] });
      queryClient.invalidateQueries({ queryKey: ["shop-shifts"] });

      toast({
        title: "Shift created",
        description: `Shift assigned to ${professional.name} and invitation sent!`,
      });

      setShowAutoSlotAssignment(false);
      setSelectedAutoSlot(null);

      // Clear optimistic shift after refetch
      setTimeout(() => {
        setOptimisticShifts(prev => prev.filter(e => e.id !== newShift.id));
      }, 2000);
    } catch (error: any) {
      toast({
        title: "Failed to create shift",
        description: error?.message || "Please try again later",
        variant: "destructive",
      });
    }
  }, [selectedAutoSlot, shiftFormData, queryClient, toast]);

  // Handle creating custom shift from auto-slot
  const handleAutoSlotCreateCustom = useCallback(() => {
    if (!selectedAutoSlot) return;
    
    // Pre-fill the form with the slot times and open the create modal
    setShiftFormData({
      title: "",
      description: "",
      date: format(selectedAutoSlot.start, "yyyy-MM-dd"),
      startTime: format(selectedAutoSlot.start, "HH:mm"),
      endTime: format(selectedAutoSlot.end, "HH:mm"),
      hourlyRate: "45",
      location: "",
    });
    
    setSelectedSlot({ start: selectedAutoSlot.start, end: selectedAutoSlot.end });
    setSelectedDate(selectedAutoSlot.start);
    
    setShowAutoSlotAssignment(false);
    setSelectedAutoSlot(null);
    setShowCreateModal(true);
  }, [selectedAutoSlot]);

  // Handle assignment from shift assignment modal
  const handleShiftAssignment = useCallback(async (professional: Professional) => {
    if (!selectedUnassignedSlot) return;

    try {
      // Create a new shift with the professional assigned
      const response = await apiRequest("POST", "/api/shifts", {
        title: `Shift - ${professional.name}`,
        description: `Assigned shift for ${professional.name}`,
        startTime: selectedUnassignedSlot.start.toISOString(),
        endTime: selectedUnassignedSlot.end.toISOString(),
        hourlyRate: shiftFormData.hourlyRate || "45",
        location: shiftFormData.location || "",
        status: "invited",
        assignedStaffId: professional.id,
        assignedStaff: {
          id: professional.id,
          name: professional.name,
          displayName: professional.displayName,
          email: professional.email,
          photoURL: professional.photoURL || professional.avatar,
        },
      });

      const newShift = await response.json();

      // Add to optimistic state immediately
      const optimisticEvent: CalendarEvent = {
        id: newShift.id,
        title: newShift.title || `Shift - ${professional.name}`,
        start: selectedUnassignedSlot.start,
        end: selectedUnassignedSlot.end,
        resource: {
          booking: {
            shift: {
              id: newShift.id,
              title: newShift.title,
              startTime: newShift.startTime,
              endTime: newShift.endTime,
              status: "invited",
              hourlyRate: newShift.hourlyRate,
              location: newShift.location,
              assignedStaff: {
                id: professional.id,
                name: professional.name,
                displayName: professional.displayName,
                email: professional.email,
                photoURL: professional.photoURL || professional.avatar,
              },
            },
          },
          status: 'invited',
          type: 'shift',
        },
      };

      setOptimisticShifts(prev => [...prev, optimisticEvent]);

      // Invalidate queries
      queryClient.invalidateQueries({ queryKey: ["/api/shifts"] });
      queryClient.invalidateQueries({ queryKey: ["shop-shifts"] });

      toast({
        title: "Shift assigned",
        description: `Shift assigned to ${professional.name} and invitation sent!`,
      });

      setShowShiftAssignmentModal(false);
      setSelectedUnassignedSlot(null);

      // Clear optimistic shift after refetch
      setTimeout(() => {
        setOptimisticShifts(prev => prev.filter(e => e.id !== newShift.id));
      }, 2000);
    } catch (error: any) {
      toast({
        title: "Failed to assign shift",
        description: error?.message || "Please try again later",
        variant: "destructive",
      });
    }
  }, [selectedUnassignedSlot, shiftFormData, queryClient, toast]);

  // Handle posting to job board from shift assignment modal
  const handlePostToJobBoard = useCallback(async () => {
    if (!selectedUnassignedSlot) return;

    try {
      // Create a new shift with 'open' status (posted to job board)
      const response = await apiRequest("POST", "/api/shifts", {
        title: "Open Shift",
        description: "Shift posted to job board",
        startTime: selectedUnassignedSlot.start.toISOString(),
        endTime: selectedUnassignedSlot.end.toISOString(),
        hourlyRate: shiftFormData.hourlyRate || "45",
        location: shiftFormData.location || "",
        status: "open",
      });

      const newShift = await response.json();

      // Add to optimistic state immediately
      const optimisticEvent: CalendarEvent = {
        id: newShift.id,
        title: newShift.title || "Open Shift",
        start: selectedUnassignedSlot.start,
        end: selectedUnassignedSlot.end,
        resource: {
          booking: {
            shift: {
              id: newShift.id,
              title: newShift.title,
              startTime: newShift.startTime,
              endTime: newShift.endTime,
              status: "open",
              hourlyRate: newShift.hourlyRate,
              location: newShift.location,
            },
          },
          status: 'open',
          type: 'shift',
        },
      };

      setOptimisticShifts(prev => [...prev, optimisticEvent]);

      // Invalidate queries
      queryClient.invalidateQueries({ queryKey: ["/api/shifts"] });
      queryClient.invalidateQueries({ queryKey: ["shop-shifts"] });

      toast({
        title: "Shift posted",
        description: "Shift has been posted to the Open Jobs board!",
      });

      setShowShiftAssignmentModal(false);
      setSelectedUnassignedSlot(null);

      // Clear optimistic shift after refetch
      setTimeout(() => {
        setOptimisticShifts(prev => prev.filter(e => e.id !== newShift.id));
      }, 2000);
    } catch (error: any) {
      toast({
        title: "Failed to post shift",
        description: error?.message || "Please try again later",
        variant: "destructive",
      });
    }
  }, [selectedUnassignedSlot, shiftFormData, queryClient, toast]);

  // Check if event is part of a recurring series
  const isRecurringEvent = useCallback((event: CalendarEvent): boolean => {
    const shift = event.resource?.booking?.shift || event.resource?.booking?.job;
    return !!(shift?.isRecurring || shift?.recurringSeriesId);
  }, []);

  // Handle Smart Fill confirmation (used by SmartFillConfirmationModal)
  const handleSmartFillConfirm = useCallback(async () => {
    try {
      // Send invites for all matches with suggested candidates
      const matchesWithCandidates = smartMatches.filter((m) => m.suggestedCandidate !== null);
      
      for (const match of matchesWithCandidates) {
        if (match.suggestedCandidate) {
          await assignStaffMutation.mutateAsync({
            shiftId: match.shiftId,
            professional: {
              id: match.suggestedCandidate.id,
              name: match.suggestedCandidate.name,
              email: match.suggestedCandidate.email,
            },
          });
        }
      }
      
      toast({
        title: "Invites sent",
        description: `Sent ${matchesWithCandidates.length} invitation(s) to matched professionals`,
      });
      
      setShowSmartFillModal(false);
      setSmartMatches([]);
    } catch (error: any) {
      toast({
        title: "Failed to send invites",
        description: error?.message || "Please try again later",
        variant: "destructive",
      });
    }
  }, [smartMatches, assignStaffMutation, toast]);

  // Handle event drop (drag-and-drop)
  const handleEventDrop = useCallback(
    ({ event, start, end }: { event: CalendarEvent; start: Date; end: Date }) => {
      // Validate dates
      if (!start || !end || isNaN(start.getTime()) || isNaN(end.getTime())) {
        toast({
          title: "Invalid time slot",
          description: "Please select a valid time slot",
          variant: "destructive",
        });
        return;
      }

      // Prevent moving events to the past (Time Travel Bug fix)
      const now = new Date();
      const startOfDay = new Date(start);
      startOfDay.setHours(0, 0, 0, 0);
      const nowStartOfDay = new Date(now);
      nowStartOfDay.setHours(0, 0, 0, 0);
      
      if (startOfDay < nowStartOfDay) {
        toast({
          title: "Cannot move shifts to the past",
          description: "Please select a date from today onwards.",
          variant: "destructive",
        });
        return;
      }

      // Check for overlapping shifts (Double Booking Bug fix)
      const overlappingEvent = events.find((e) => {
        if (e.id === event.id) return false; // Skip the event being moved
        // Check if the new time slot overlaps with existing events
        return (
          (start >= e.start && start < e.end) ||
          (end > e.start && end <= e.end) ||
          (start <= e.start && end >= e.end)
        );
      });

      if (overlappingEvent) {
        toast({
          title: "Time slot already booked",
          description: "This time slot overlaps with an existing shift. Please choose a different time.",
          variant: "destructive",
        });
        return;
      }

      // Ensure end is after start
      const validEnd = end > start ? end : new Date(start.getTime() + 60 * 60 * 1000);

      // Check if this is a recurring shift
      if (isRecurringEvent(event)) {
        // Show dialog to ask user if they want to move this shift only or all future shifts
        setPendingRecurringAction({
          type: 'move',
          event,
          newStart: start,
          newEnd: validEnd,
        });
        setShowRecurringDialog(true);
        return;
      }

      // Non-recurring shift - proceed with update
      updateEventMutation.mutate({
        id: event.id,
        start,
        end: validEnd,
      });
    },
    [updateEventMutation, toast, isRecurringEvent, events]
  );

  // Handle event resize
  const handleEventResize = useCallback(
    ({ event, start, end }: { event: CalendarEvent; start: Date; end: Date }) => {
      // Validate dates
      if (!start || !end || isNaN(start.getTime()) || isNaN(end.getTime())) {
        toast({
          title: "Invalid time slot",
          description: "Please select a valid time slot",
          variant: "destructive",
        });
        return;
      }

      // Prevent resizing events to the past (Time Travel Bug fix)
      const now = new Date();
      const startOfDay = new Date(start);
      startOfDay.setHours(0, 0, 0, 0);
      const nowStartOfDay = new Date(now);
      nowStartOfDay.setHours(0, 0, 0, 0);
      
      if (startOfDay < nowStartOfDay) {
        toast({
          title: "Cannot resize shifts to the past",
          description: "Please select a date from today onwards.",
          variant: "destructive",
        });
        return;
      }

      // Check for overlapping shifts (Double Booking Bug fix)
      const overlappingEvent = events.find((e) => {
        if (e.id === event.id) return false; // Skip the event being resized
        // Check if the new time slot overlaps with existing events
        return (
          (start >= e.start && start < e.end) ||
          (end > e.start && end <= e.end) ||
          (start <= e.start && end >= e.end)
        );
      });

      if (overlappingEvent) {
        toast({
          title: "Time slot already booked",
          description: "This time slot overlaps with an existing shift. Please choose a different time.",
          variant: "destructive",
        });
        return;
      }

      // Ensure end is after start
      const validEnd = end > start ? end : new Date(start.getTime() + 60 * 60 * 1000);

      // Check if this is a recurring shift
      if (isRecurringEvent(event)) {
        // Show dialog to ask user if they want to resize this shift only or all future shifts
        setPendingRecurringAction({
          type: 'move',
          event,
          newStart: start,
          newEnd: validEnd,
        });
        setShowRecurringDialog(true);
        return;
      }

      // Non-recurring shift - proceed with update
      updateEventMutation.mutate({
        id: event.id,
        start,
        end: validEnd,
      });
    },
    [updateEventMutation, toast, isRecurringEvent, events]
  );

  // Handle recurring action confirmation
  const handleRecurringAction = useCallback(
    (applyToAll: boolean) => {
      if (!pendingRecurringAction) return;

      const { type, event, newStart, newEnd } = pendingRecurringAction;

      if (type === 'move' && newStart && newEnd) {
        // For now, we'll just update the single shift
        // In a full implementation, you'd need to:
        // 1. If applyToAll: Find all future shifts in the series and update them
        // 2. If !applyToAll: Just update this shift (and potentially break the series)
        updateEventMutation.mutate({
          id: event.id,
          start: newStart,
          end: newEnd,
        });
      } else if (type === 'delete') {
        // Handle delete - would need to implement delete mutation
        // For now, just show a message
        toast({
          title: "Delete recurring shift",
          description: applyToAll 
            ? "All future shifts in this series will be deleted"
            : "Only this shift will be deleted",
        });
      }

      setShowRecurringDialog(false);
      setPendingRecurringAction(null);
    },
    [pendingRecurringAction, updateEventMutation, toast]
  );

  const handleCreateEvent = () => {
    // Use form data if available, otherwise fall back to selectedSlot
    let startTime: Date;
    let endTime: Date;
    let dateStr: string;

    if (shiftFormData.date && shiftFormData.startTime && shiftFormData.endTime) {
      // Use form data
      dateStr = shiftFormData.date;
      startTime = new Date(`${shiftFormData.date}T${shiftFormData.startTime}`);
      endTime = new Date(`${shiftFormData.date}T${shiftFormData.endTime}`);
    } else if (selectedSlot) {
      // Fallback to selected slot
      if (isNaN(selectedSlot.start.getTime()) || isNaN(selectedSlot.end.getTime())) {
        toast({
          title: "Invalid time slot",
          description: "Please select a valid time slot",
          variant: "destructive",
        });
        return;
      }
      startTime = selectedSlot.start;
      endTime = selectedSlot.end;
      dateStr = format(selectedSlot.start, "yyyy-MM-dd");
    } else if (selectedDate) {
      // Fallback: use selectedDate if no slot selected
      startTime = new Date(selectedDate);
      startTime.setHours(9, 0, 0, 0);
      endTime = new Date(selectedDate);
      endTime.setHours(17, 0, 0, 0);
      dateStr = format(selectedDate, "yyyy-MM-dd");
    } else {
      toast({
        title: "Missing information",
        description: "Please select a date and time for the shift",
        variant: "destructive",
      });
      return;
    }

    // Validate: End time must be after start time
    if (endTime <= startTime) {
      toast({
        title: "Invalid time range",
        description: "End time must be after start time.",
        variant: "destructive",
      });
      return;
    }

    // Prevent creating events in the past (Time Travel Bug fix)
    const now = new Date();
    const startOfDay = new Date(startTime);
    startOfDay.setHours(0, 0, 0, 0);
    const nowStartOfDay = new Date(now);
    nowStartOfDay.setHours(0, 0, 0, 0);
    
    if (startOfDay < nowStartOfDay) {
      toast({
        title: "Cannot create shifts in the past",
        description: "Please select a date from today onwards.",
        variant: "destructive",
      });
      return;
    }

    // Check for overlapping shifts (Double Booking Bug fix)
    const overlappingEvent = events.find((e) => {
      // Check if the new time slot overlaps with existing events
      return (
        (startTime >= e.start && startTime < e.end) ||
        (endTime > e.start && endTime <= e.end) ||
        (startTime <= e.start && endTime >= e.end)
      );
    });

    if (overlappingEvent) {
      toast({
        title: "Time slot already booked",
        description: "This time slot overlaps with an existing shift. Please choose a different time.",
        variant: "destructive",
      });
      return;
    }

    createEventMutation.mutate({
      title: shiftFormData.title || newEventTitle || "New Event",
      start: startTime,
      end: endTime,
      description: shiftFormData.description,
      hourlyRate: shiftFormData.hourlyRate || "45",
      location: shiftFormData.location,
      professional: selectedProfessional,
    });
  };

  return (
    <div className="flex flex-col lg:flex-row gap-6 h-full">
      {/* Left Sidebar - 25% */}
      <div className="w-full lg:w-1/4 space-y-4 bg-gradient-to-br from-slate-900/50 via-purple-900/20 to-blue-900/20 dark:from-slate-800/80 dark:via-purple-900/30 dark:to-blue-900/30 dark:border-slate-700/60 p-4 rounded-lg border border-slate-800/50">
        {/* Mini Calendar */}
        <Card>
          <CardHeader>
            <CardTitle className="text-lg" data-testid="quick-navigation-title">Quick Navigation</CardTitle>
          </CardHeader>
          <CardContent className="p-4">
            <CalendarComponent
              mode="single"
              selected={selectedDate}
              onSelect={handleMiniCalendarSelect}
              className="w-full"
              modifiersClassNames={{
                today: "font-semibold bg-accent",
              }}
            />
            {/* Quick Day Navigation */}
            <div className="mt-4 pt-4 border-t">
              <div className="grid grid-cols-7 gap-1 text-center text-xs">
                {["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"].map((day, idx) => (
                  <div key={day} className="text-muted-foreground font-medium py-1">
                    {day}
                  </div>
                ))}
                {eachDayOfInterval({
                  start: startOfWeek(new Date(), { weekStartsOn: 0 }),
                  end: endOfWeek(new Date(), { weekStartsOn: 0 }),
                }).map((day, idx) => {
                  const isSelected = selectedDate && isSameDay(day, selectedDate);
                  const isCurrentDay = isSameDay(day, new Date());
                  return (
                    <button
                      key={idx}
                      onClick={() => handleMiniCalendarSelect(day)}
                      className={`
                        aspect-square rounded-md text-xs font-medium transition-colors
                        ${isSelected ? "bg-primary text-primary-foreground" : ""}
                        ${isCurrentDay && !isSelected ? "bg-accent text-accent-foreground border border-primary/20" : ""}
                        ${!isSelected && !isCurrentDay ? "hover:bg-accent" : ""}
                      `}
                    >
                      {format(day, "d")}
                    </button>
                  );
                })}
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Create Availability/Shift Button */}
        <Card>
          <CardContent className="pt-6">
            <Button
              onClick={() => {
                if (mode === 'business' && onCreateShift) {
                  // Business mode: Open Create New Shift modal
                  onCreateShift();
                } else {
                  // Professional mode: Open Create Availability modal
                  const today = new Date();
                  setSelectedDate(today);
                  setSelectedSlot(null); // Clear slot selection for manual creation
                  setNewEventTitle("");
                  // Initialize form with today's date and default times
                  setShiftFormData({
                    title: "",
                    description: "",
                    date: format(today, "yyyy-MM-dd"),
                    startTime: "09:00",
                    endTime: "17:00",
                    hourlyRate: "45",
                    location: "",
                  });
                  setShowCreateModal(true);
                }
              }}
              className="w-full"
              size="lg"
              data-testid={mode === 'business' ? "button-create-shift" : "button-create-availability"}
            >
              <Plus className="mr-2 h-4 w-4" />
              {mode === 'business' ? 'Create New Shift' : 'Create Availability'}
            </Button>
          </CardContent>
        </Card>

        {/* Empty State Message */}
        {!isLoading && filteredEvents.length === 0 && (
          <Card>
            <CardContent className="pt-6">
              <div className="text-center space-y-2">
                <CalendarIcon className="h-8 w-8 text-muted-foreground mx-auto" />
                <p className="text-sm font-medium text-foreground">
                  {mode === 'business' ? 'No shifts scheduled' : 'No shifts scheduled'}
                </p>
                <p className="text-xs text-muted-foreground">
                  {mode === 'business' 
                    ? 'Create a new shift to get started' 
                    : 'Create availability to start booking shifts'}
                </p>
              </div>
            </CardContent>
          </Card>
        )}

        {/* Filters */}
        <Card>
          <CardHeader>
            <CardTitle className="text-lg flex items-center gap-2">
              <Filter className="h-4 w-4" />
              Filters
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div>
              <label className="text-sm font-medium mb-2 block">Job Status</label>
              <Select value={statusFilter} onValueChange={(value) => setStatusFilter(value as JobStatus)}>
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">All</SelectItem>
                  <SelectItem value="pending">Pending</SelectItem>
                  <SelectItem value="confirmed">Confirmed</SelectItem>
                  <SelectItem value="completed">Completed</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Legend - Traffic Light System */}
            <div className="space-y-2 pt-4 border-t">
              <p className="text-sm font-medium">Legend</p>
              <div className="space-y-1.5 text-xs">
                <div className="flex items-center gap-2">
                  <div className="w-3 h-3 rounded bg-emerald-500"></div>
                  <span>Confirmed</span>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-3 h-3 rounded bg-yellow-500"></div>
                  <span>Open Slot</span>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-3 h-3 rounded bg-zinc-500"></div>
                  <span>Past</span>
                </div>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Main Calendar Area - 75% */}
      <div className="flex-1 lg:w-3/4" data-testid="calendar-main-area">
        <Card className="h-full flex flex-col bg-background">
          <CalendarToolbar
            mode={mode}
            view={view}
            onViewChange={handleViewChange}
            onNavigate={navigate}
            onSettingsClick={() => setShowCalendarSettings(true)}
            onSmartFillClick={handleSmartFillClick}
            isCalculatingMatches={isCalculatingMatches}
          />
          <CardContent className="flex-1 p-4 overflow-hidden" style={{ minHeight: '650px', height: '100%' }}>
            {isLoading ? (
              <div className="flex items-center justify-center h-full min-h-[600px]">
                <div className="text-muted-foreground">Loading calendar...</div>
              </div>
            ) : (
              <div 
                className="relative" 
                ref={calendarRef} 
                style={{ 
                  minHeight: view === 'month' ? '600px' : view === 'week' ? '700px' : '600px',
                  height: view === 'month' ? '600px' : view === 'week' ? '700px' : '600px',
                  width: '100%'
                }}
              >
                {/* Legend - Traffic Light System */}
                <div className="flex gap-4 mb-4 text-sm text-zinc-400 flex-wrap">
                  <div className="flex items-center gap-2">
                    <div className="w-3 h-3 rounded bg-emerald-500"></div>
                    <span>Confirmed</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-3 h-3 rounded bg-yellow-500"></div>
                    <span>Open Slot</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-3 h-3 rounded bg-zinc-500"></div>
                    <span>Past</span>
                  </div>
                </div>
                
                {/* Date Range Display */}
                {dateRange && (
                  <div className="mb-2 text-sm font-medium text-muted-foreground">
                    {view === "day" ? (
                      format(dateRange.start, "EEEE, MMMM d, yyyy")
                    ) : view === "week" ? (
                      `${format(dateRange.start, "MMM d")} - ${format(dateRange.end, "MMM d, yyyy")}`
                    ) : view === "month" ? (
                      format(currentDate, "MMMM yyyy")
                    ) : null}
                  </div>
                )}
                
                {/* Calendar component - filteredEvents is always an array due to defensive coding */}
                {/* Ensure events is always a valid array for react-big-calendar */}
                {(() => {
                  console.log('[CALENDAR RENDER] Starting Calendar render function');
                  console.log('[CALENDAR RENDER] isLoading:', isLoading);
                  console.log('[CALENDAR RENDER] filteredEvents count:', Array.isArray(filteredEvents) ? filteredEvents.length : 'not array');
                  try {
                    // Comprehensive prop validation
                    const safeEvents = Array.isArray(filteredEvents) ? filteredEvents : [];
                    
                    // Validate localizer
                    if (!localizer) {
                      console.error('[CALENDAR ERROR] Localizer not initialized - Calendar cannot render');
                      return (
                        <div className="flex items-center justify-center h-full min-h-[600px]" data-testid="calendar-error-localizer">
                          <div className="text-muted-foreground">Calendar initialization error: Localizer not initialized. Check console for details.</div>
                        </div>
                      );
                    }
                    
                    // Localizer is already validated above, no need for additional checks
                    
                    // Validate currentDate
                    if (!currentDate || !(currentDate instanceof Date) || isNaN(currentDate.getTime())) {
                      console.error('[CALENDAR ERROR] Invalid currentDate:', currentDate);
                      return (
                        <div className="flex items-center justify-center h-full min-h-[600px]" data-testid="calendar-error-date">
                          <div className="text-muted-foreground">Calendar initialization error: Invalid date</div>
                        </div>
                      );
                    }
                    
                    // Validate view
                    const validViews: View[] = ['month', 'week', 'day', 'agenda'];
                    if (!validViews.includes(view)) {
                      console.error('[CALENDAR ERROR] Invalid view:', view);
                      return (
                        <div className="flex items-center justify-center h-full min-h-[600px]" data-testid="calendar-error-view">
                          <div className="text-muted-foreground">Calendar initialization error: Invalid view</div>
                        </div>
                      );
                    }
                    
                    // Validate events structure
                    const invalidEvents = safeEvents.filter((event: any) => {
                      return !event || 
                             !(event.start instanceof Date) || 
                             !(event.end instanceof Date) ||
                             isNaN(event.start.getTime()) ||
                             isNaN(event.end.getTime());
                    });
                    
                    if (invalidEvents.length > 0) {
                      console.warn('[CALENDAR WARNING] Found invalid events:', invalidEvents.length);
                    }
                    
                    // Log prop validation success
                    console.log('[CALENDAR DEBUG] Props validated:', {
                      eventsCount: safeEvents.length,
                      localizerType: typeof localizer,
                      currentDate: currentDate.toISOString(),
                      view: view
                    });
                    
                    // Calculate height based on view for stable rendering
                    const calendarHeight = view === 'month' ? 600 : view === 'week' ? 700 : 600;
                    
                    // Render Calendar with error boundary
                    return (
                      <div 
                        data-testid="react-big-calendar-container" 
                        style={{ 
                          height: `${calendarHeight}px`, 
                          minHeight: `${calendarHeight}px`,
                          width: '100%',
                          position: 'relative'
                        }}
                      >
                        <CalendarErrorBoundary>
                          <Calendar
                            localizer={localizer}
                            events={safeEvents}
                            startAccessor="start"
                            endAccessor="end"
                            style={{ 
                              height: `${calendarHeight}px`, 
                              minHeight: `${calendarHeight}px`,
                              width: '100%'
                            }}
                            view={view}
                            onView={handleViewChange}
                            date={currentDate}
                            onNavigate={handleNavigate}
                            onSelectEvent={handleSelectEvent}
                            onSelectSlot={handleSelectSlot}
                            onEventDrop={handleEventDrop}
                            onEventResize={handleEventResize}
                            selectable
                            resizable
                            draggableAccessor={(event: CalendarEvent) => {
                              // Allow dragging only if event is not in the past
                              const now = new Date();
                              return event.end >= now;
                            }}
                            eventPropGetter={eventStyleGetter}
                            min={new Date(2020, 0, 1, 0, 0, 0)}
                            max={new Date(2030, 11, 31, 23, 59, 59)}
                            minTime={getEarliestOpeningTime()}
                            maxTime={new Date(2020, 0, 1, 23, 59, 59)}
                            scrollToTime={getEarliestOpeningTime()}
                            components={{
                              toolbar: customToolbar,
                              header: customHeader,
                              event: ({ event }: { event: CalendarEvent }) => {
                                // Use ShiftBlock for business mode, enhanced rendering for professional mode
                                if (mode === 'business') {
                                  const shift = event.resource?.booking?.shift || event.resource?.booking?.job;
                                  const isRecurring = shift?.isRecurring || shift?.recurringSeriesId;
                                  return (
                                    <ShiftBlock
                                      event={event}
                                      onClick={() => handleSelectEvent(event)}
                                      isRecurring={isRecurring}
                                    />
                                  );
                                }
                                // Enhanced event rendering for professional mode with status indicators
                                const shift = event.resource?.booking?.shift || event.resource?.booking?.job;
                                const assignedStaff = shift?.assignedStaff || shift?.professional;
                                const isAssigned = !!assignedStaff;
                                const status = event.resource?.status || shift?.status || "DRAFT";
                                
                                return (
                                  <div className="text-xs p-0.5">
                                    <div className="font-semibold truncate">{event.title}</div>
                                    <div className="flex items-center gap-1 opacity-90">
                                      {isAssigned ? (
                                        <span>Ã°Å¸â€˜Â¤ {assignedStaff?.name || assignedStaff?.displayName || "Assigned"}</span>
                                      ) : (status === "PUBLISHED" || status === "OPEN" || status === "invited" || status === "pending") ? (
                                        <span>Ã¢Å¡Â Ã¯Â¸Â Open</span>
                                      ) : null}
                                    </div>
                                  </div>
                                );
                              },
                            }}
                            tooltipAccessor={(event: CalendarEvent) => {
                              const shift = event.resource?.booking?.shift || event.resource?.booking?.job;
                              const assignedStaff = shift?.assignedStaff || shift?.professional;
                              const isAssigned = !!assignedStaff;
                              const status = event.resource?.status || shift?.status || "DRAFT";
                              const statusText = isAssigned ? "Booked" : (status === "PUBLISHED" || status === "OPEN" || status === "invited" || status === "pending") ? "Open" : "Draft";
                              const workerName = assignedStaff?.name || assignedStaff?.displayName;
                              return `${event.title} - ${format(event.start, 'h:mm a')} - ${statusText}${workerName ? ` (${workerName})` : ''}`;
                            }}
                            formats={{
                              dayFormat: (date: Date, culture?: string, localizer?: any) => {
                                try {
                                  // Use date-fns format for week/day view headers: "Mon 12/10"
                                  return format(date, "EEE d/M", { locale: enUS });
                                } catch (e) {
                                  console.error('[CALENDAR ERROR] dayFormat error:', e);
                                  return format(date, "EEE M/d", { locale: enUS });
                                }
                              },
                              weekdayFormat: (date: Date, culture?: string, localizer?: any) => {
                                try {
                                  // Format for month view weekday headers: "Mon"
                                  return format(date, "EEE", { locale: enUS });
                                } catch (e) {
                                  console.error('[CALENDAR ERROR] weekdayFormat error:', e);
                                  return format(date, "EEE", { locale: enUS });
                                }
                              },
                              dayHeaderFormat: (date: Date, culture?: string, localizer?: any) => {
                                try {
                                  // Week view day headers: "Mon 12/10"
                                  return format(date, "EEE d/M", { locale: enUS });
                                } catch (e) {
                                  console.error('[CALENDAR ERROR] dayHeaderFormat error:', e);
                                  return format(date, "EEE M/d", { locale: enUS });
                                }
                              },
                              dayRangeHeaderFormat: ({ start, end }) => {
                                try {
                                  return `${format(start, "MMM d", { locale: enUS })} - ${format(end, "MMM d, yyyy", { locale: enUS })}`;
                                } catch (e) {
                                  console.error('[CALENDAR ERROR] dayRangeHeaderFormat error:', e);
                                  return `${start.toLocaleDateString()} - ${end.toLocaleDateString()}`;
                                }
                              },
                              monthHeaderFormat: "MMMM yyyy",
                              timeGutterFormat: "h:mm a",
                              eventTimeRangeFormat: ({ start, end }) => {
                                try {
                                  return `${format(start, "h:mm a")} - ${format(end, "h:mm a")}`;
                                } catch (e) {
                                  console.error('[CALENDAR ERROR] eventTimeRangeFormat error:', e);
                                  return `${start.toLocaleTimeString()} - ${end.toLocaleTimeString()}`;
                                }
                              },
                            }}
                          />
                        </CalendarErrorBoundary>
                      </div>
                    );
                  } catch (error) {
                    console.error('[CALENDAR ERROR] Fatal error rendering Calendar component:', error);
                    console.error('[CALENDAR ERROR] Error stack:', error instanceof Error ? error.stack : 'No stack trace');
                    return (
                      <div className="flex items-center justify-center h-full min-h-[600px]" data-testid="calendar-error-fatal">
                        <div className="text-muted-foreground">
                          Error loading calendar: {error instanceof Error ? error.message : String(error)}
                        </div>
                      </div>
                    );
                  }
                })()}
                {/* Current Time Indicator - only show in week/day view */}
                {view === "week" || view === "day" ? (
                  <CurrentTimeIndicator
                    currentTime={currentTime}
                    view={view}
                    currentDate={currentDate}
                  />
                ) : null}
              </div>
            )}
          </CardContent>
        </Card>
      </div>

      {/* Event Details Sheet */}
      <Sheet open={showEventDetails} onOpenChange={setShowEventDetails}>
        <SheetContent className="w-full sm:max-w-lg max-h-[85vh] overflow-y-auto">
          <SheetHeader>
            <SheetTitle>{selectedEvent?.title || "Event Details"}</SheetTitle>
            <SheetDescription>
              {selectedEvent && (
                <Badge
                  className={
                    selectedEvent.resource.status === "confirmed"
                      ? "bg-green-600"
                      : selectedEvent.resource.status === "pending"
                      ? "bg-blue-600"
                      : "bg-gray-600"
                  }
                >
                  {selectedEvent.resource.status.charAt(0).toUpperCase() +
                    selectedEvent.resource.status.slice(1)}
                </Badge>
              )}
            </SheetDescription>
          </SheetHeader>
          {selectedEvent && (
            <div className="mt-6 space-y-4">
              <div className="flex items-center gap-2 text-sm">
                <CalendarIcon className="h-4 w-4 text-muted-foreground" />
                <span>
                  {format(selectedEvent.start, "EEEE, MMMM d, yyyy")}
                </span>
              </div>
              <div className="flex items-center gap-2 text-sm">
                <Clock className="h-4 w-4 text-muted-foreground" />
                <span>
                  {format(selectedEvent.start, "h:mm a")} -{" "}
                  {format(selectedEvent.end, "h:mm a")}
                </span>
              </div>
              {(selectedEvent.resource.booking.job?.address ||
                selectedEvent.resource.booking.shift?.location) && (
                <div className="flex items-center gap-2 text-sm">
                  <MapPin className="h-4 w-4 text-muted-foreground" />
                  <span>
                    {selectedEvent.resource.booking.job?.address ||
                      selectedEvent.resource.booking.shift?.location}
                  </span>
                </div>
              )}
              {(selectedEvent.resource.booking.job?.payRate ||
                selectedEvent.resource.booking.shift?.hourlyRate) && (
                <div className="flex items-center gap-2 text-sm">
                  <DollarSign className="h-4 w-4 text-muted-foreground" />
                  <span>
                    $
                    {selectedEvent.resource.booking.job?.payRate ||
                      selectedEvent.resource.booking.shift?.hourlyRate}
                    /{selectedEvent.resource.booking.job?.payType || "hour"}
                  </span>
                </div>
              )}
              {selectedEvent.resource.booking.job?.description && (
                <div className="pt-4 border-t">
                  <p className="text-sm text-muted-foreground">
                    {selectedEvent.resource.booking.job.description}
                  </p>
                </div>
              )}
              <div className="flex gap-2 pt-4">
                {selectedEvent.resource.booking.job?.hubId && (
                  <StartChatButton
                    otherUserId={selectedEvent.resource.booking.job.hubId}
                    otherUserName="Employer"
                    otherUserRole="hub"
                    variant="outline"
                    className="flex-1"
                  />
                )}
                <Button variant="outline" className="flex-1">
                  View Details
                </Button>
                {mode === 'business' && isRecurringEvent(selectedEvent) && (
                  <Button
                    variant="destructive"
                    className="flex-1"
                    onClick={() => {
                      setPendingRecurringAction({
                        type: 'delete',
                        event: selectedEvent,
                      });
                      setShowRecurringDialog(true);
                    }}
                  >
                    <Trash2 className="h-4 w-4 mr-2" />
                    Delete
                  </Button>
                )}
              </div>
              {mode === 'business' && isRecurringEvent(selectedEvent) && (
                <div className="pt-2 border-t flex items-center gap-2 text-sm text-muted-foreground">
                  <Repeat className="h-4 w-4" />
                  <span>This is part of a recurring series</span>
                </div>
              )}
            </div>
          )}
        </SheetContent>
      </Sheet>

      {/* Recurring Shift Action Dialog */}
      <AlertDialog open={showRecurringDialog} onOpenChange={setShowRecurringDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Recurring Shift</AlertDialogTitle>
            <AlertDialogDescription>
              {pendingRecurringAction?.type === 'delete'
                ? "This shift is part of a recurring series. What would you like to do?"
                : "This shift is part of a recurring series. Would you like to apply this change to all future shifts?"}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={() => {
              setShowRecurringDialog(false);
              setPendingRecurringAction(null);
            }}>
              Cancel
            </AlertDialogCancel>
            {pendingRecurringAction?.type === 'delete' ? (
              <>
                <AlertDialogAction
                  className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                  onClick={() => handleRecurringAction(false)}
                >
                  This Shift Only
                </AlertDialogAction>
                <AlertDialogAction
                  className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                  onClick={() => handleRecurringAction(true)}
                >
                  All Future Shifts
                </AlertDialogAction>
              </>
            ) : (
              <>
                <AlertDialogAction onClick={() => handleRecurringAction(false)}>
                  This Shift Only
                </AlertDialogAction>
                <AlertDialogAction onClick={() => handleRecurringAction(true)}>
                  All Future Shifts
                </AlertDialogAction>
              </>
            )}
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Quick Event Creation Modal */}
      <Sheet open={showCreateModal} onOpenChange={(open) => {
        setShowCreateModal(open);
        if (!open) {
          // Reset form when closing
          setSelectedSlot(null);
          setSelectedDate(undefined);
          setNewEventTitle("");
          setShowFindProfessionalMode(false);
          setSelectedProfessional(null);
          setShowInviteSearch(false);
          setInviteSearchQuery("");
          setShiftFormData({
            title: "",
            description: "",
            date: "",
            startTime: "09:00",
            endTime: "17:00",
            hourlyRate: "45",
            location: "",
          });
        }
      }}>
        <SheetContent className="max-h-[85vh] overflow-y-auto">
          <SheetHeader>
            <SheetTitle>
              {mode === 'business' ? 'Create Shift' : 'Create New Event'}
            </SheetTitle>
            <SheetDescription>
              {selectedSlot ? (
                <>
                  {mode === 'business' ? 'Create a shift' : 'Create an event'} from {format(selectedSlot.start, "MMM d, h:mm a")} to {format(selectedSlot.end, "h:mm a")}
                </>
              ) : selectedDate ? (
                <>{mode === 'business' ? 'Create a shift' : 'Create an event'} for {format(selectedDate, "MMMM d, yyyy")}</>
              ) : (
                mode === 'business' ? "Create a new shift" : "Create a new event"
              )}
            </SheetDescription>
          </SheetHeader>
          <div className="mt-6 space-y-4">
            {/* Unified Create & Invite Form */}
            <form onSubmit={(e) => { e.preventDefault(); handleCreateEvent(); }} className="space-y-6">
                <div>
                  <Label htmlFor="event-title">Shift Title *</Label>
                  <Input
                    id="event-title"
                    required
                    placeholder="e.g., Weekend Barber Needed"
                    value={shiftFormData.title || newEventTitle}
                    onChange={(e) => {
                      setShiftFormData({ ...shiftFormData, title: e.target.value });
                      setNewEventTitle(e.target.value);
                    }}
                    className="bg-zinc-900 border-zinc-700"
                    autoFocus
                  />
                </div>

                <div>
                  <Label htmlFor="description">Description</Label>
                  <Textarea
                    id="description"
                    rows={3}
                    value={shiftFormData.description}
                    onChange={(e) => setShiftFormData({ ...shiftFormData, description: e.target.value })}
                    placeholder="Describe the shift requirements... (e.g., Barber needed for busy Saturday)"
                    className="bg-zinc-900 border-zinc-700"
                  />
                </div>

                <div>
                  <Label htmlFor="date">Date *</Label>
                  <Input
                    id="date"
                    type="date"
                    required
                    value={shiftFormData.date || (selectedSlot ? format(selectedSlot.start, "yyyy-MM-dd") : selectedDate ? format(selectedDate, "yyyy-MM-dd") : "")}
                    onChange={(e) => setShiftFormData({ ...shiftFormData, date: e.target.value })}
                    min={format(new Date(), "yyyy-MM-dd")}
                    className="bg-zinc-900 border-zinc-700"
                  />
                </div>

                <div className="grid grid-cols-2 gap-4">
                  <div className="space-y-2">
                    <Label htmlFor="startTime">Start Time *</Label>
                    <Input
                      id="startTime"
                      type="time"
                      required
                      value={shiftFormData.startTime}
                      onChange={(e) => setShiftFormData({ ...shiftFormData, startTime: e.target.value })}
                      className="bg-zinc-900 border-zinc-700"
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="endTime">End Time *</Label>
                    <Input
                      id="endTime"
                      type="time"
                      required
                      value={shiftFormData.endTime}
                      onChange={(e) => setShiftFormData({ ...shiftFormData, endTime: e.target.value })}
                      className="bg-zinc-900 border-zinc-700"
                    />
                  </div>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <Label htmlFor="hourlyRate">Hourly Rate ($) *</Label>
                    <Input
                      id="hourlyRate"
                      type="number"
                      step="0.01"
                      required
                      value={shiftFormData.hourlyRate}
                      onChange={(e) => setShiftFormData({ ...shiftFormData, hourlyRate: e.target.value })}
                      placeholder="45.00"
                      className="bg-zinc-900 border-zinc-700"
                    />
                  </div>
                  <div>
                    <Label htmlFor="location">Location</Label>
                    <Input
                      id="location"
                      value={shiftFormData.location}
                      onChange={(e) => setShiftFormData({ ...shiftFormData, location: e.target.value })}
                      placeholder="e.g., 123 Main St, City, State"
                      className="bg-zinc-900 border-zinc-700"
                    />
                  </div>
                </div>
                
                {/* Optional: Invite Professional Section (Business Mode Only) */}
                {mode === 'business' && (
                  <div className="border-t pt-4 space-y-4">
                    <div className="flex items-center space-x-2">
                      <Checkbox
                        id="invite-professional"
                        checked={showInviteSearch}
                        onCheckedChange={(checked) => {
                          setShowInviteSearch(checked === true);
                          if (!checked) {
                            setSelectedProfessional(null);
                            setInviteSearchQuery("");
                          }
                        }}
                      />
                      <Label htmlFor="invite-professional" className="cursor-pointer font-medium">
                        Invite a specific professional? (Optional)
                      </Label>
                    </div>
                    
                    {showInviteSearch && (
                      <div className="ml-6 space-y-4 pl-4 border-l-2">
                        <div className="relative">
                          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                          <Input
                            placeholder="Search by name or skill..."
                            value={inviteSearchQuery}
                            onChange={(e) => setInviteSearchQuery(e.target.value)}
                            className="pl-10"
                          />
                        </div>
                        
                        {selectedProfessional ? (
                          <div className="p-3 border rounded-lg bg-muted/50">
                            <div className="flex items-center justify-between">
                              <div className="flex items-center gap-3">
                                <Avatar className="h-10 w-10">
                                  <AvatarImage src={selectedProfessional.photoURL || selectedProfessional.avatar} />
                                  <AvatarFallback>{getInitials(selectedProfessional.name)}</AvatarFallback>
                                </Avatar>
                                <div>
                                  <div className="flex items-center gap-2">
                                    <div className="font-medium">{selectedProfessional.name}</div>
                                    {isFavorite(selectedProfessional.id) && (
                                      <Star className="h-3 w-3 fill-yellow-400 text-yellow-400" />
                                    )}
                                  </div>
                                  {selectedProfessional.rating && (
                                    <div className="text-sm text-muted-foreground">Ã¢Â­Â {selectedProfessional.rating}</div>
                                  )}
                                </div>
                              </div>
                              <div className="flex items-center gap-2">
                                <Button
                                  type="button"
                                  variant="ghost"
                                  size="sm"
                                  className="h-8 w-8 p-0"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    toggleFavorite(selectedProfessional.id);
                                  }}
                                  title={isFavorite(selectedProfessional.id) ? "Remove from favorites" : "Add to favorites"}
                                >
                                  <Star className={`h-4 w-4 ${isFavorite(selectedProfessional.id) ? 'fill-yellow-400 text-yellow-400' : 'text-muted-foreground'}`} />
                                </Button>
                                <Button
                                  type="button"
                                  variant="ghost"
                                  size="sm"
                                  onClick={() => setSelectedProfessional(null)}
                                >
                                  Change
                                </Button>
                              </div>
                            </div>
                          </div>
                        ) : (
                          <div className="max-h-60 overflow-y-auto space-y-4">
                            {filteredProfessionals.length === 0 ? (
                              <div className="text-center py-4 text-sm text-muted-foreground">
                                No professionals found
                              </div>
                            ) : (
                              <>
                                {/* Favorites Section */}
                                {favoriteProfessionals.length > 0 && (
                                  <div>
                                    <div className="flex items-center gap-2 mb-2">
                                      <Star className="h-4 w-4 fill-yellow-400 text-yellow-400" />
                                      <h4 className="text-sm font-semibold">Favorites</h4>
                                    </div>
                                    <div className="space-y-2">
                                      {favoriteProfessionals.map((professional) => (
                                        <div
                                          key={professional.id}
                                          className="flex items-center justify-between p-3 border-2 border-yellow-200 dark:border-yellow-800 rounded-lg hover:bg-accent transition-colors cursor-pointer bg-yellow-50/50 dark:bg-yellow-950/20"
                                          onClick={() => setSelectedProfessional(professional)}
                                        >
                                          <div className="flex items-center gap-3 flex-1 min-w-0">
                                            <Avatar className="h-10 w-10">
                                              <AvatarImage src={professional.photoURL || professional.avatar} />
                                              <AvatarFallback>{getInitials(professional.name)}</AvatarFallback>
                                            </Avatar>
                                            <div className="flex-1 min-w-0">
                                              <div className="flex items-center gap-2">
                                                <div className="font-medium truncate">{professional.name}</div>
                                                <Star className="h-3 w-3 fill-yellow-400 text-yellow-400 flex-shrink-0" />
                                              </div>
                                              {professional.rating && (
                                                <div className="text-sm text-muted-foreground">Ã¢Â­Â {professional.rating}</div>
                                              )}
                                              {professional.skills && professional.skills.length > 0 && (
                                                <div className="flex gap-1 mt-1 flex-wrap">
                                                  {professional.skills.slice(0, 3).map((skill, idx) => (
                                                    <Badge key={idx} variant="secondary" className="text-xs">
                                                      {skill}
                                                    </Badge>
                                                  ))}
                                                </div>
                                              )}
                                            </div>
                                          </div>
                                          <div className="flex items-center gap-2">
                                            <Button
                                              type="button"
                                              variant="ghost"
                                              size="sm"
                                              className="h-8 w-8 p-0"
                                              onClick={(e) => {
                                                e.stopPropagation();
                                                toggleFavorite(professional.id);
                                              }}
                                              title={isFavorite(professional.id) ? "Remove from favorites" : "Add to favorites"}
                                            >
                                              <Star className={`h-4 w-4 ${isFavorite(professional.id) ? 'fill-yellow-400 text-yellow-400' : 'text-muted-foreground'}`} />
                                            </Button>
                                            <Button
                                              type="button"
                                              size="sm"
                                              onClick={(e) => {
                                                e.stopPropagation();
                                                setSelectedProfessional(professional);
                                              }}
                                            >
                                              <UserPlus className="h-4 w-4 mr-1" />
                                              Select
                                            </Button>
                                          </div>
                                        </div>
                                      ))}
                                    </div>
                                  </div>
                                )}
                                
                                {/* Other Professionals Section */}
                                {otherProfessionals.length > 0 && (
                                  <div>
                                    {favoriteProfessionals.length > 0 && (
                                      <h4 className="text-sm font-semibold mb-2">All Professionals</h4>
                                    )}
                                    <div className="space-y-2">
                                      {otherProfessionals.map((professional) => (
                                        <div
                                          key={professional.id}
                                          className="flex items-center justify-between p-3 border rounded-lg hover:bg-accent transition-colors cursor-pointer"
                                          onClick={() => setSelectedProfessional(professional)}
                                        >
                                          <div className="flex items-center gap-3 flex-1 min-w-0">
                                            <Avatar className="h-10 w-10">
                                              <AvatarImage src={professional.photoURL || professional.avatar} />
                                              <AvatarFallback>{getInitials(professional.name)}</AvatarFallback>
                                            </Avatar>
                                            <div className="flex-1 min-w-0">
                                              <div className="font-medium truncate">{professional.name}</div>
                                              {professional.rating && (
                                                <div className="text-sm text-muted-foreground">Ã¢Â­Â {professional.rating}</div>
                                              )}
                                              {professional.skills && professional.skills.length > 0 && (
                                                <div className="flex gap-1 mt-1 flex-wrap">
                                                  {professional.skills.slice(0, 3).map((skill, idx) => (
                                                    <Badge key={idx} variant="secondary" className="text-xs">
                                                      {skill}
                                                    </Badge>
                                                  ))}
                                                </div>
                                              )}
                                            </div>
                                          </div>
                                          <div className="flex items-center gap-2">
                                            <Button
                                              type="button"
                                              variant="ghost"
                                              size="sm"
                                              className="h-8 w-8 p-0"
                                              onClick={(e) => {
                                                e.stopPropagation();
                                                toggleFavorite(professional.id);
                                              }}
                                              title={isFavorite(professional.id) ? "Remove from favorites" : "Add to favorites"}
                                            >
                                              <Star className={`h-4 w-4 ${isFavorite(professional.id) ? 'fill-yellow-400 text-yellow-400' : 'text-muted-foreground'}`} />
                                            </Button>
                                            <Button
                                              type="button"
                                              size="sm"
                                              onClick={(e) => {
                                                e.stopPropagation();
                                                setSelectedProfessional(professional);
                                              }}
                                            >
                                              <UserPlus className="h-4 w-4 mr-1" />
                                              Select
                                            </Button>
                                          </div>
                                        </div>
                                      ))}
                                    </div>
                                  </div>
                                )}
                              </>
                            )}
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                )}
                
                <div className="flex gap-2 pt-4">
                  <Button
                    type="button"
                    variant="outline"
                    onClick={() => {
                      setShowCreateModal(false);
                      setSelectedSlot(null);
                      setSelectedDate(undefined);
                      setNewEventTitle("");
                      setShowFindProfessionalMode(false);
                      setShiftFormData({
                        title: "",
                        description: "",
                        date: "",
                        startTime: "09:00",
                        endTime: "17:00",
                        hourlyRate: "45",
                        location: "",
                      });
                    }}
                    className="flex-1"
                  >
                    Cancel
                  </Button>
                  <Button
                    type="submit"
                    disabled={createEventMutation.isPending}
                    className="flex-1"
                  >
                    {createEventMutation.isPending
                      ? "Creating..."
                      : selectedProfessional
                        ? `Create & Invite ${selectedProfessional.name}`
                        : mode === 'business' ? "Create Shift" : "Create Event"}
                  </Button>
                </div>
              </form>
          </div>
        </SheetContent>
      </Sheet>

      {/* Assign Staff Modal */}
      {mode === 'business' && selectedShiftForAssignment && (
        <AssignStaffModal
          isOpen={showAssignStaffModal}
          onClose={() => {
            setShowAssignStaffModal(false);
            setSelectedShiftForAssignment(null);
          }}
          onAssign={handleAssignStaff}
          professionals={allProfessionals}
          favoriteProfessionals={favoriteProfessionals}
          shiftTitle={selectedShiftForAssignment.title}
          shiftDate={selectedShiftForAssignment.start}
        />
      )}

      {/* Smart Fill Confirmation Modal */}
      {mode === 'business' && (
        <SmartFillConfirmationModal
          open={showSmartFillModal}
          onOpenChange={setShowSmartFillModal}
          matches={smartMatches}
          onConfirm={handleSmartFillConfirm}
          isLoading={isCalculatingMatches}
        />
      )}

      {/* Calendar Settings Modal */}
      {mode === 'business' && (
        <CalendarSettingsModal
          isOpen={showCalendarSettings}
          onClose={() => setShowCalendarSettings(false)}
          onSave={handleSaveSettings}
          initialSettings={calendarSettings || undefined}
        />
      )}

      {/* Auto-Slot Assignment Modal */}
      {mode === 'business' && selectedAutoSlot && (
        <AutoSlotAssignmentModal
          isOpen={showAutoSlotAssignment}
          onClose={() => {
            setShowAutoSlotAssignment(false);
            setSelectedAutoSlot(null);
          }}
          slot={selectedAutoSlot}
          favoriteProfessionals={favoriteProfessionals}
          allProfessionals={allProfessionals}
          onAssign={handleAutoSlotAssign}
          onCreateCustom={handleAutoSlotCreateCustom}
          isLoading={false}
        />
      )}

      {/* Shift Assignment Modal */}
      {mode === 'business' && selectedUnassignedSlot && (
        <ShiftAssignmentModal
          isOpen={showShiftAssignmentModal}
          onClose={() => {
            setShowShiftAssignmentModal(false);
            setSelectedUnassignedSlot(null);
          }}
          onAssign={handleShiftAssignment}
          onPostToJobBoard={handlePostToJobBoard}
          start={selectedUnassignedSlot.start}
          end={selectedUnassignedSlot.end}
          favoriteProfessionals={favoriteProfessionals}
          allProfessionals={allProfessionals}
          isLoading={false}
        />
      )}
    </div>
  );
}

