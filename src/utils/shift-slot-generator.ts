import { CalendarSettings, ShiftPattern, OpeningHours } from "@/components/calendar/calendar-settings-modal";
import { format, startOfDay, addDays, isSameDay, isPast, isToday } from "date-fns";

export interface GeneratedShiftSlot {
  id: string; // Virtual ID for auto-generated slots
  start: Date;
  end: Date;
  dayOfWeek: string;
  slotIndex: number; // Index within the day (0, 1, 2 for thirds, etc.)
  pattern: ShiftPattern;
  isAutoGenerated: true;
  status: 'unassigned' | 'open';
}

/**
 * Calculate shift slots for a given day based on opening hours and shift pattern
 */
export function calculateShiftSlotsForDay(
  date: Date,
  openingHours: OpeningHours,
  pattern: ShiftPattern,
  customShiftLength?: number
): GeneratedShiftSlot[] {
  const dayOfWeek = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'][date.getDay()];
  const dayHours = openingHours[dayOfWeek];

  // If day is not enabled or no hours set, return empty array
  if (!dayHours || !dayHours.enabled || !dayHours.open || !dayHours.close) {
    return [];
  }

  const [openHour, openMin] = dayHours.open.split(':').map(Number);
  const [closeHour, closeMin] = dayHours.close.split(':').map(Number);

  const dayStart = startOfDay(date);
  const openTime = new Date(dayStart);
  openTime.setHours(openHour, openMin, 0, 0);

  const closeTime = new Date(dayStart);
  closeTime.setHours(closeHour, closeMin, 0, 0);

  // Ensure close time is after open time
  if (closeTime <= openTime) {
    return [];
  }

  // Use integer-minute math to avoid floating ms drift (can show up as “random” 10:00 labels in month view)
  // and to make thirds/halves splits stable across the entire month.
  const totalMinutes = Math.round((closeTime.getTime() - openTime.getTime()) / (1000 * 60));
  const slots: GeneratedShiftSlot[] = [];

  switch (pattern) {
    case 'half-day': {
      const halfMinutes = Math.round(totalMinutes / 2);
      const midTime = new Date(openTime);
      midTime.setMinutes(midTime.getMinutes() + halfMinutes);
      
      slots.push({
        id: `auto-${format(date, 'yyyy-MM-dd')}-0`,
        start: openTime,
        end: midTime,
        dayOfWeek,
        slotIndex: 0,
        pattern: 'half-day',
        isAutoGenerated: true,
        status: 'unassigned',
      });
      
      slots.push({
        id: `auto-${format(date, 'yyyy-MM-dd')}-1`,
        start: midTime,
        end: closeTime,
        dayOfWeek,
        slotIndex: 1,
        pattern: 'half-day',
        isAutoGenerated: true,
        status: 'unassigned',
      });
      break;
    }

    case 'thirds': {
      // If open/close aligns to a clean 3-way split (e.g. 09:00–18:00),
      // enforce exact boundaries to keep month-view times consistent.
      const thirdMinutes = Math.round(totalMinutes / 3);
      const firstThird = new Date(openTime);
      firstThird.setMinutes(firstThird.getMinutes() + thirdMinutes);
      const secondThird = new Date(openTime);
      secondThird.setMinutes(secondThird.getMinutes() + (thirdMinutes * 2));
      
      slots.push({
        id: `auto-${format(date, 'yyyy-MM-dd')}-0`,
        start: openTime,
        end: firstThird,
        dayOfWeek,
        slotIndex: 0,
        pattern: 'thirds',
        isAutoGenerated: true,
        status: 'unassigned',
      });
      
      slots.push({
        id: `auto-${format(date, 'yyyy-MM-dd')}-1`,
        start: firstThird,
        end: secondThird,
        dayOfWeek,
        slotIndex: 1,
        pattern: 'thirds',
        isAutoGenerated: true,
        status: 'unassigned',
      });
      
      slots.push({
        id: `auto-${format(date, 'yyyy-MM-dd')}-2`,
        start: secondThird,
        end: closeTime,
        dayOfWeek,
        slotIndex: 2,
        pattern: 'thirds',
        isAutoGenerated: true,
        status: 'unassigned',
      });
      break;
    }

    case 'custom': {
      // Handle decimal hours (e.g., 4.5 hours = 4 hours 30 minutes)
      const shiftLengthMinutes = Math.round((customShiftLength || 8) * 60);
      let currentStart = openTime;
      let slotIndex = 0;

      while (currentStart < closeTime) {
        const slotEnd = new Date(currentStart.getTime() + shiftLengthMinutes * 60 * 1000);
        // Option A: Create a shorter final shift (Partial Shift) - Default behavior
        const actualEnd = slotEnd > closeTime ? closeTime : slotEnd;
        
        // Only create slot if it's at least 15 minutes (minimum viable shift)
        const slotDuration = (actualEnd.getTime() - currentStart.getTime()) / (1000 * 60);
        if (slotDuration >= 15) {
          slots.push({
            id: `auto-${format(date, 'yyyy-MM-dd')}-${slotIndex}`,
            start: new Date(currentStart),
            end: actualEnd,
            dayOfWeek,
            slotIndex,
            pattern: 'custom',
            isAutoGenerated: true,
            status: 'unassigned',
          });
        }

        currentStart = actualEnd;
        slotIndex++;

        // Prevent infinite loop
        if (slotIndex > 20) break;
      }
      break;
    }

    case 'full-day':
    default: {
      slots.push({
        id: `auto-${format(date, 'yyyy-MM-dd')}-0`,
        start: openTime,
        end: closeTime,
        dayOfWeek,
        slotIndex: 0,
        pattern: 'full-day',
        isAutoGenerated: true,
        status: 'unassigned',
      });
      break;
    }
  }

  return slots;
}

/**
 * Generate shift slots for a date range
 */
export function generateShiftSlotsForRange(
  startDate: Date,
  endDate: Date,
  settings: CalendarSettings
): GeneratedShiftSlot[] {
  const slots: GeneratedShiftSlot[] = [];
  const currentDate = new Date(startDate);

  while (currentDate <= endDate) {
    // UI: generate slots for the entire visible range (including past days),
    // so the calendar shows the configured opening-hours segments "all over" the view.
    // Slot actions (invite/post) can still be blocked for past dates at the UI layer.
    const daySlots = calculateShiftSlotsForDay(
      currentDate,
      settings.openingHours,
      settings.shiftPattern,
      settings.defaultShiftLength
    );
    slots.push(...daySlots);

    currentDate.setDate(currentDate.getDate() + 1);
  }

  return slots;
}

/**
 * Check if a generated slot overlaps with an existing shift
 */
export function slotOverlapsWithShift(
  slot: GeneratedShiftSlot,
  existingShifts: Array<{ start: Date | string; end: Date | string }>
): boolean {
  const slotStart = slot.start;
  const slotEnd = slot.end;

  return existingShifts.some(shift => {
    const shiftStart = new Date(shift.start);
    const shiftEnd = new Date(shift.end);

    // Check for overlap
    return (
      (slotStart >= shiftStart && slotStart < shiftEnd) ||
      (slotEnd > shiftStart && slotEnd <= shiftEnd) ||
      (slotStart <= shiftStart && slotEnd >= shiftEnd)
    );
  });
}

/**
 * Filter out auto-generated slots that overlap with existing shifts
 */
export function filterOverlappingSlots(
  generatedSlots: GeneratedShiftSlot[],
  existingShifts: Array<{ start: Date | string; end: Date | string }>
): GeneratedShiftSlot[] {
  return generatedSlots.filter(slot => !slotOverlapsWithShift(slot, existingShifts));
}

